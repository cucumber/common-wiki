The regular expression matching in [[Step Definitions]] lets you capture small strings from  your
steps and receive them in your step definitions. However, there are times when you want to pass
a richer data structure from a step to a step definition.

This is what multiline step arguments are for. They are written on the lines right underneath a step,
and will be yielded as the last argument to the matching step definition's block.

Multiline step arguments come in two flavours - tables or strings.

h2. Tables

Tables as arguments to steps are handy for specifying a larger data set - usually as input to a <code>Given</code> or as expected output from a <code>Then</code>. (This is not to be confused with tables in [[Scenario outlines]] - syntactically identical, but with a different purpose). Example:

<pre><code>Given the following people exist:
  | name  | email           | phone |
  | Aslak | aslak@email.com | 123   |
  | Joe   | joe@email.com   | 234   |
  | Bryan | bryan@email.org | 456   |
</code></pre>

-and a matching step definition:

<pre><code>Given /the following people exist:/ do |people_table|
  people_table.hashes.each do |hash|
    # The first time the +hash+ will contain:
    #   {'name' => 'Aslak', 'email' => 'aslak@email.com', 'phone' => '123'} 
    # The second time:
    #   {'name' => 'Joe', 'email' => 'joe@email.com', 'phone' => '234'}
    # etc.
  end
end
</code></pre>

A plain text table gets stored in a <code>Cucumber::Ast::Table</code> object, which provides several methods to access the
rows, columns and cells in the table. In the example above we're using the <code>Cucumber::Ast::Table#hashes</code> method to iterate over all of the rows.

h3. Diffing tables

As of Cucumber 0.3.90 you can compare a table argument to another table. This is something you would typically do in a Then step, and the other table would typically be constructed programmatically from your application's data. The diffing is done with the <code>Cucumber::Ast::Table#diff!(table)</code> method. Here is an example:

<pre>
Then I should see the following cukes:
  | Latin           | English      |
  | Cucumis sativus | Cucumber     |
  | Cucumis anguria | Burr Gherkin |
</pre>

And a Step Definition that uses <code>diff!</code>:

<pre>
Then /^I should see the following cukes:$/ do |expected_cukes_table|
  actual_table = [
    ['Latin', 'English'],
    ['Cucumis sativus', 'Concombre'],
    ['Cucumis anguria', 'Burr Gherkin']
  ] # In practice you'd pull this out of a web page, database or some other data store.

  expected_cukes_table.diff!(actual_table)
end
</pre>

Cucumber will print the difference:

| *{color:green}Latin*           | *{color:green}English*      |
| *{color:yellow}Cucumis sativus* | *{color:yellow}Cucumber*     |
| *{color:grey}Cucumis sativus* | *{color:grey}Concombre*    |
| *{color:green}Cucumis anguria* | *{color:green}Burr Gherkin* |

(Due to limitations of this wiki, this will look slightly different in a console).

Missing rows and columns are printed in grey (same colour as comments), and surplus rows and columns are printed in yellow (same colour as undefined steps). When the two tables differ, the step will fail. You can modify this behaviour by passing an options Hash to the <code>diff!</code> method. See [[RDoc]] for details.

The table argument to the <code>diff!</code> method can be one of the following:

* Another <code>CucumberAst::Table</code>
* An <code>Array</code> containing <code>Array</code>s with <code>String</code>s
* An <code>Array</code> containing <code>Hash</code>es with <code>String => String</code> (similar to the structure returned by <code>CucumberAst::Table#hashes</code>).

In most cases you have to construct that table yourself programmatically, but for convenience, Cucumber ships with a handy method for Webrat users that will turn a HTML table into an Array of Array. Example:

<pre>
expected_cukes_table.diff!(table_at('#cuke_table').to_a)
</pre>

h4. Stripping HTML

If your HTML Table contains e.g. links and you want to create a table structure containing the link text, you can convert the column values. Example:

<pre>
actual_table = table(table_at('#cuke_table').to_a)
actual_table.map_column!('Artist') { |text| text.strip.match(/>(.*)</)[1] }
expected_cukes_table.diff!(actual_table)
</pre>

Let's consider a more complex example where you have a HTML table with an "Actions" column where each td contains buttons similar to this: 

<pre>
<form method="post" action="/invoices/10/approve" class="button-to"><div><input id="approve_invoice_10" type="submit" value="Approve" /><input name="authenticity_token" type="hidden" value="WxKGVy3Y5zcvFEiFe66D/odoc3CicfMdAup4vzQfiZ0=" /></div></form>
<form method="post" action="/invoices/10/delegate" class="button-to"><div><input id="delegate_invoice_10" type="submit" value="Delegate" /><input name="authenticity_token" type="hidden" value="WxKGVy3Y5zcvFEiFe66D/odoc3CicfMdAup4vzQfiZ0=" /></div></form>
</pre>

You only care about the button texts and you want compare with a plain text table like this:

<pre>
| Invoice | Action           |
|    2001 | Approve,Delegate |
|    2002 | Reject           |
</pre>

In this case, mapping a column with a Regexp might be a little tricky. In such cases it might be easier to use Nokogiri and a CSS selector:

<pre>
Then /^I should see the following invoices:$/ do |invoices|
  t = table(element_at("#invoices").to_table)
  t.map_column%