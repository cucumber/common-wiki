The regular expression matching in [[Step Definitions]] lets you capture small strings from  your
steps and receive them in your step definitions. However, there are times when you want to pass
a richer data structure from a step to a step definition.

This is what multiline step arguments are for. They are written on the lines right underneath a step,
and will be yielded as the last argument to the matching step definition's block.

Multiline step arguments come in two flavours - tables or strings.

h2. Tables

Tables as arguments to steps are handy for specifying a larger data set - usually as input to a <code>Given</code> or as expected output from a <code>Then</code>. (This is not to be confused with tables in [[Scenario outlines]] - syntactically identical, but with a different purpose). Example:

<pre><code>Given the following people exist:
  | name  | email           | phone |
  | Aslak | aslak@email.com | 123   |
  | Joe   | joe@email.com   | 234   |
  | Bryan | bryan@email.org | 456   |
</code></pre>

-and a matching step definition:

<pre><code>Given /the following people exist:/ do |people_table|
  people_table.hashes.each do |hash|
    # The first time the +hash+ will contain:
    #   {'name' => 'Aslak', 'email' => 'aslak@email.com', 'phone' => '123'} 
    # The second time:
    #   {'name' => 'Joe', 'email' => 'joe@email.com', 'phone' => '234'}
    # etc.
  end
end
</code></pre>

A plain text table gets stored in a <code>Cucumber::Ast::Table</code> object, which provides several methods to access the
rows, columns and cells in the table. In the example above we're using the <code>Cucumber::Ast::Table#hashes</code> method to iterate over all of the rows.

h3. Diffing tables

As of Cucumber 0.3.90 you can compare a table argument to another table. This is something you would typically do in a Then step, and the other table would typically be constructed programmatically from your application's data. The diffing is done with the <code>Cucumber::Ast::Table#diff!(table)</code> method. Here is an example:

<pre>
Then I should see the following cukes:
  | Latin           | English      |
  | Cucumis sativus | Cucumber     |
  | Cucumis anguria | Burr Gherkin |
</pre>

And a Step Definition that uses <code>diff!</code>:

<pre>
Then /^I should see the following cukes:$/ do |expected_cukes_table|
  actual_table = [
    ['Latin', 'English'],
    ['Cucumis sativus', 'Concombre'],
    ['Cucumis anguria', 'Burr Gherkin']
  ] # In practice you'd pull this out of a web page, database or some other data store.

  expected_cukes_table.diff!(actual_table)
end
</pre>

Cucumber will print the difference:

| *{color:green}Latin*           | *{color:green}English*      |
| *{color:yellow}Cucumis sativus* | *{color:yellow}Cucumber*     |
| *{color:grey}Cucumis sativus* | *{color:grey}Concombre*    |
| *{color:green}Cucumis anguria* | *{color:green}Burr Gherkin* |

(Due to limitations of this wiki, this will look slightly different in a console).

Missing rows and columns are printed in grey (same colour as comments), and surplus rows and columns are printed in yellow (same colour as undefined steps). When the two tables differ, the step will fail. You can modify this behaviour by passing an options Hash to the <code>diff!</code> method. See [[RDoc]] for details.

The table argument to the <code>diff!</code> method can be one of the following:

* Another <code>CucumberAst::Table</code>
* An <code>Array</code> containing <code>Array</code>s with <code>String</code>s
* An <code>Array</code> containing <code>Hash</code>es with <code>String => String</code> (similar to the structure returned by <code>CucumberAst::Table#hashes</code>).

In most cases you have to construct that table yourself programmatically, but for convenience, Cucumber ships with a handy method for Webrat users that will turn a HTML table into an Array of Array. Example:

<pre>
expected_cukes_table.diff!(table_at('#cuke_table').to_a)
</pre>

h4. Stripping HTML

If your HTML Table contains e.g. links and you want to create a table structure containing the link text, you can convert the column values. Example:

<pre>
actual_table = table(table_at('#cuke_table').to_a)
actual_table.map_column!('Artist') { |text| text.strip.match(/>(.*)</)[1] }
expected_cukes_table.diff!(actual_table)
</pre>

Let's consider a more complex example where you have a HTML table with an "Actions" column where each td contains buttons similar to this: 

<pre>
<form method="post" action="/invoices/10/approve" class="button-to"><div><input id="approve_invoice_10" type="submit" value="Approve" /><input name="authenticity_token" type="hidden" value="WxKGVy3Y5zcvFEiFe66D/odoc3CicfMdAup4vzQfiZ0=" /></div></form>
<form method="post" action="/invoices/10/delegate" class="button-to"><div><input id="delegate_invoice_10" type="submit" value="Delegate" /><input name="authenticity_token" type="hidden" value="WxKGVy3Y5zcvFEiFe66D/odoc3CicfMdAup4vzQfiZ0=" /></div></form>
</pre>

You only care about the button texts and you want compare with a plain text table like this:

<pre>
| Invoice | Action           |
| 2001    | Approve,Delegate |
| 2002    | Reject           |
</pre>

In this case, mapping a column with a Regexp might be a little tricky. In such cases it might be easier to use Nokogiri and a CSS selector:

<pre>
Then /^I should see the following invoices:$/ do |invoices|
  t = table(element_at("#invoices").to_table)
  t.map_column!('Handling') do |buttons|
    Nokogiri::HTML("<html>#{buttons}</html>").css('input').map{|b| b['value']}.join(",")
  end
  invoices.diff!(t)
end
</pre>

h4. ActiveRecord

You can also easily turn Rails ActiveRecord objects into a table:

<pre>
expected_cukes_table.diff!(Cuke.find(:all).map(&:attributes))
</pre>

(This is not a recommended practice - your Then steps should compare against what users *see*, and they can't *see* your database).

If you are not using Webrat or ActiveRecord, you can build up table structures yourself. Use your imagination!

h2. Multiline Strings

Multiline Strings are handy for specifying a larger piece of text. This is done using the PyString syntax. (The inspiration for PyString comes from Python where """ is used to delineate docstrings.)  The text should be offset by delimiters consisting of three double-quote marks on lines of their own:

<pre><code>Given a blog post named "Random" with Markdown body
  """
  Some Title, Eh?
  ==============
  Here is the first paragraph of my blog post. Lorem ipsum dolor sit amet,
  consectetur adipiscing elit.
  """
</code></pre>

In your step definition, there's no need to find this text and match it in your Regexp. It will automatically be yielded as the last parameter in the step definition.  For example:

<pre><code>Given /^a blog post named "([^\"]*)" with Markdown body$/ do |title, markdown|
  Post.create!(:title => title, :body => markdown)
end
</code></pre>

Indentation of the opening <code>"""</code> is unimportant, although common practice is two spaces in from the enclosing step. The indentation <em>inside</em> the triple quotes, however, <em>is</em> significant. Each line of the string passed to the step definition's block will be de-indented according to the opening <code>"""</code>. Indentation beyond the column of the opening <code>"""</code> will therefore be preserved.

Cucumber stores multiline strings internally as a <code>Cucumber::Ast::PyString</code> object. However,
this gets converted to a regular <code>String</code> before it's passed to the step definition.

h3. Diffing multiline strings

If you're using [[RSpec Expectations]], you can compare strings simply with

<pre>
string_from_step.should == actual_string
</pre>

If they are different, the step will fail with an error displaying the difference as a "unified diff":http://en.wikipedia.org/wiki/Diff.

h2. Substitution in Scenario Outlines

If you use a multiline argument in steps in [[Scenario Outlines]], any <code>< ></code> 
delimited tokens will be substituted with values from the example tables. For example:

<pre><code>Scenario Outline: Email confirmation
  Given I have a user account with my name "Jojo Binks"
  When an Admin grants me <Role> rights
  Then I should receive an email with the body:
    """
    Dear Jojo Binks,
    You have been granted <Role> rights.  You are <details>. Please be responsible.
    -The Admins
    """
  Examples:
    |  Role     | details                                         |
    |  Manager  | now able to manage your employee accounts       |
    |  Admin    | able to manage any user account on the system   |
</code></pre>

Or with tables:

<pre><code>Scenario Outline: Multiplying with 7
  Given I have the numbers
    | q1   | q2 | product |
    | <x>  |  7 | <y>     |
  Examples:
    |  x |  y |
    |  2 | 14 |
    | 10 | 70 |
</code></pre>

h2. Using regular arguments and multiline arguments

It's possible to pass regular arguments in addition to multiline arguments. This is illustrated
for strings above in the blog example. Here is an example using tables:

<pre><code># ruby
Given /^an expense report for (.*) with the following posts:$/ do |date, posts_table|
  # The posts_table variable is an instance of Cucumber::Ast::Table
end
</code></pre>

This can easily be called from a plain text step like this:

<pre><code># feature
Given an expense report for Jan 2009 with the following posts:
  | account | description | amount |
  | INT-100 | Taxi        |    114 |
  | CUC-101 | Peeler      |     22 |
</code></pre>

Also see [[Calling Steps from Step Definitions]] for a related example.
