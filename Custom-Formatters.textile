As Cucumber runs your features, it calls out to any number of listener objects to let them know how it's progressing. These listeners are notified at various points throughout the run of features.

To create a custom formatter, you will need to write a class and configure it to respond to certain events, as shown:
```ruby
class CustomFormatter
  attr_reader :io

  def initialize(config)
    @io = config.out_stream

    config.on_event :test_case_started do |event|
      feature = event.test_cases.first.source.first
      io.puts feature.short_name.upcase
    end
  end
end
```

Available events are:
* test_case_started
* test_case_finished
* test_step_started
* test_step_finished
* step_definition_registered
* step_activated
* test_run_started
* test_run_finished
* gherkin_source_read

In each case, the event object is passed into the block in <code>config.on_event</code>. Each event object belongs to an event class corresponding to the specific event in question, e.g., <code>Cucumber::Events::TestRunStarted</code>, <code>Cucumber::Events::GherkinSourceRead</code>, etc. Depending on the event, different objects are accessible through methods called on the event object. For instance, for the <code>Cucumber::Events::GherkinSourceRead</code> event, the Gherkin body is available using the <code>#body</code> method, and for the <code>Cucumber::Events::TestCaseStarted</code> event, the individual test cases (features) are available via the <code>#test_cases</code> method.

h2. Deprecated API

The older formatter API has been deprecated and will be removed in Cucumber 4. For reference purposes, we will continue to provide an overview of this here; however, you are advised to update any custom formatters to use the newer API described above.

For an example of the older API, take this simple scenario in Cucumber's own test suite:

<pre>
$ head -7 examples/self_test/features/sample.feature
# Feature comment
@one
Feature: Sample

  @two @three
  Scenario: Missing
    Given missing
</pre>

Here are the events fired to a listener when that scenario is run, shown using the debug formatter:

<pre>
$ cucumber --format debug examples/self_test/sample.feature:6
before_features
  before_feature
    before_comment
      comment_line
    after_comment
    before_tags
      tag_name
    after_tags
    feature_name
    before_feature_element
      before_tags
        tag_name
        tag_name
      after_tags
      scenario_name
      before_steps
        before_step
          before_step_result
            step_name
          after_step_result
        after_step
      after_steps
    after_feature_element
  after_feature
after_features
</pre> 

If you want to write your own custom formatter, just create a class that implements any of the methods you see in the output from the debug formatter. Let's illustrate this with an example.

Maybe you want to create a formatter that posts a message to Twitter every time a step fails? (I'm sure that would get you a lot of followers).

Here is how you'd do that:

Save your custom formatter class in <code>features/support</code> (or if you want to put it elsewhere, put a file in that directory that <code>require</code>s your formatter class).

<pre>
# features/support/twitter_formatter.rb
require 'rubygems'
require 'twitter'

module Silly
  class TwitterFormatter
    def initialize(step_mother, io, options)
      # We don't care about these - we're just twittering!
    end

    def step_name(keyword, step_match, status, source_indent, background, file_colon_line)
      if status == :failed
        step_name = step_match.format_args(lambda{|param| "*#{param}*"})
        message = "#{step_name} FAILED"
        Twitter::Base.new('your email', 'your password').post(message)
      end
    end
  end
end
</pre>

Now you can run your features by passing <code>--format Silly::TwitterFormatter</code> to the <code>cucumber</code> command line, Rake task or even in <code>cucumber.yml</code> - see [[Running Features]] for all the options. You have more methods available than the ones used in this awesome example (but you only need to implement the ones you care about). Look at the sources for some of Cucumber's built-in formatters to discover more methods.

h2. If your formatter can't be found

If cucumber complains that it can't find your formatter, add an explicit <code>--require dir</code>, where <code>dir</code> is a parent directory of your formatter. You can also pass the full path to the ruby file where the formatter is defined.

The cucumber <code>--help</code> states:

bq.. Automatic loading is disabled when this option is specified, and all loading becomes explicit. Files under directories named "support" are always loaded first.

p. This means that you have to add your <code>support</code> folder to <code>--require dir</code> for it to be loaded.

h2. Other Formatters

# TeamCity - prints cucumber results in a format for interpretation by a "TeamCity":http://www.jetbrains.com/teamcity/index.html build agent.
## "teamcity_formatter":https://github.com/kevinrood/teamcity_formatter - Compatible with Cucumber 2.
## "cucumber_teamcity":https://github.com/ankurcha/cucumber_teamcity/ - Tested with Cucumber 1.3.18 and TeamCity 8.x.
# "TextmateFormatter":http://github.com/raldred/cucumber_textmate/ prints cucumber results as HTML with enhanced styling and Javascript for Textmate (Included in the cucumber core since 0.4.5)
# "SlowHandCuke":http://github.com/moredip/SlowHandCuke - Simple tweak to the Pretty formatter to display the currently running step as it is running
# "timestamped-scenarios":https://github.com/moredip/timestamped-scenarios - Append test run timestamps to each scenario name as it is being output.
# "Fivemat":https://github.com/tpope/fivemat - Cucumber formatter that gives each test file its own line of dots.
# "Fuubar":http://github.com/martinciu/fuubar-cucumber - The instafailing progress bar formatter
# "Viewcumber":https://github.com/versapay/viewcumber -  Cucumber formatter which generates an HTML website to browse your scenarios and view screen capture of every single step.
# "cucumber_timing_presenter":https://github.com/distributedlife/cucumber_timing_presenter - formatter that calculates timing metrics as well as two graphs showing impact of step time on overall build time.
# "Bilgerat":https://github.com/mdsol/bilgerat - formatter that sends failure messages to "HipChat":https://www.hipchat.com/ rooms. 
# "cucumber_statistics":https://github.com/alienfast/cucumber_statistics - Tracks timing and displays results in a single html page with outliers highlighted in a table sortable by various metrics.
# "cucumber_characteristics":https://github.com/singram/cucumber_characteristics - Generates html/json report on overall tests timings as well as timings and usage of steps, features and examples. Also lists unused and ambiguous (Cucumber 1.x) steps.  Compatible with cucumber 1.x and 2.1+ and ruby 1.9+.
# "allure-cucumber":https://github.com/allure-framework/allure-cucumber - "Allure":https://github.com/allure-framework adaptor for Cucumber. This formatter generates the XML files for Allure reporting framework.  
# "report builder":https://github.com/rajatthareja/ReportBuilder - Ruby gem to merge Cucumber JSON reports and build mobile-friendly HTML Test Report, JSON report and retry file.