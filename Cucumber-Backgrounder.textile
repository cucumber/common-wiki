h2. Or: How I Learned to Stop Worrying and Love Testing

h3. Introduction

This document deals principally with initial set up and first use of the <strong><em> Cucumber</em></strong> gem, a behaviour driven development (BDD) tool, for a project using the Ruby on Rails (RoR) framework.  Discussion of "Behaviour Driven":http://en.wikipedia.org/wiki/Behavior_driven_development, "Test Driven":http://en.wikipedia.org/wiki/Test-driven_development (TDD), and "Panic Driven Development":http://en.wikipedia.org/wiki/SNAFU (SNAFU aka "Cowboy Coding":http://en.wikipedia.org/wiki/Cowboy_coding) can be found elsewhere.  Details regarding installing the Cucumber gem and its recommended support tools for RoR are found at [[Ruby on Rails]].  "Getting Started with Rails":http://www.ultrasaurus.com/code/2008/12/getting-started-with-rails.html is a useful introductory tutorial dealing with Rails and Cucumber.  Using cucumber outside the RoR framework will be covered in another document, when I get time to write it and have something useful to say.

h3. Where to Start?

<pre>Given you have installed the gem named "rails"
  And you have generated a RoR project named "my_project"
  And you have installed the gem named "cucumber"
  And your session working directory is the Rails root directory of "my_project"

When you run "script/generate cucumber"

Then you will create a sub-directory named "features"
  And you will create the default feature and step files in the directory named "features"
  And you will create a rake task named "cucumber.rake" in "lib/tasks"
</pre>

The foregoing is written in the style of the feature statements, called <em>steps</em>, that make up the user interface to cucumber testing.  We will return to that topic later.  For the moment we deal with the logical arrangement of cucumber files within the context of a RoR project.

The root level of the archetypal RoR project directory tree looks like this:

<pre><code>MyProject
|-- README
|-- Rakefile
|-- app
|-- config
|-- db
|-- doc
|-- lib
|-- log
|-- public
|-- script
|-- test
|-- tmp
`-- vendor
</code></pre>

Running script/generate cucumber adds this layout to the existing structure:
<pre><code>|-- features
|   |-- step_definitions
|   |   `-- webrat_steps.rb
|   `-- support
|       `-- env.rb
</code></pre>

We are now ready to begin testing with cucumber.

h3.  Where do I put Tests?

Cucumber divides testing into two parts, the outward facing feature <em>steps</em> and the inward facing <em>step definitions</em>.  As discussed elsewhere, [[Feature Introduction|features]] are descriptions of desired outcomes (<strong>Then</strong>) following upon specific events (<strong>When</strong>) under predefined conditions (<strong>Given</strong>).  They are typically used in conjunction with end-user input and, in some cases, may be entirely under end-user (in the form of a domain expert) control. Feature files are given the extension <code>.feature</code>.  

A source of potential confusion is that the term <em><strong>steps</strong></em>, when used loosely, has two, closely related but vitally distinct, meanings depending on context.  Inside feature.feature files, steps are the textual descriptions which form the body of a scenario.  These are prefaced with Given, When, Then, and And (note as well that the capitalization of these four keywords/method names is significant).  Inside a step_definitions.rb file, steps (which strictly speaking should always be called step definitions) refers to the <em>matcher</em> methods, given exactly the same names (Given, When, or Then, but *not And*),  each provided with a matcher regexp that corresponds to one or more feature steps.  Note that the method name does NOT form part of the matcher.  A Given feature clause can match a When step definition matcher.

[[Step Organisation|Step definitions]], keyed by their snippets of text from the feature files, invoke blocks of ruby and rails code that usually contains assertion statements from whatever test system you have installed.  Given that cucumber evolved out of RSpec stories it is unsurprising that the cucumber generator assumes that rspec is available, as is evidenced in the default contents of <code>features/support/env.rb</code>:

<pre><code># cucumber-0.1.11
# Sets up the Rails environment for Cucumber
ENV["RAILS_ENV"] = "test"
require File.expand_path(File.dirname(__FILE__) + '/../../config/environment')
require 'cucumber/rails/world'
Cucumber::Rails.use_transactional_fixtures

require 'webrat/rails'

# Comment out the next two lines if you're not using RSpec's matchers (should / should_not) in your steps.
require 'cucumber/rails/rspec'
require 'webrat/rspec-rails'
</code></pre>

You are not limited to this testing framework however.  If you choose to use Rails built-in TestUnit, or any other testing suite, then you may do that by extending the cucumber working environment as explained in [[Using Test::Unit]].

As detailed above, the default features directory tree is fairly shallow.  One can put every feature into a single file in the features directory and every step in a single file in the steps_definition directory (or even in the features directory itself) if one so chooses.  One can choose to have one or more feature files for each feature together with one or more step files for each feature file; or any combination thereof.  However, cucumber is programmed with the flexibility to support a much more expressive directory structure.  For instance:

<pre><code>|-- features
|   |-- entities
|   |   |-- entity.feature
|   |   `-- step_definitions
|   |       |-- anything.rb
|   |       `-- entity_steps.rb
|   |-- locations
|   |   |-- location.feature
|   |   `-- step_definitions
|   |       `-- location_steps.rb
|   |-- sites
|   |   `-- step_definitions
|   |-- step_definitions
|   |   `-- webrat_steps.rb
|   `-- support
|       `-- env.rb
</code></pre>

In this case the bland initial setup has been divided into sub-directories informed by model-centric testing.  This could equally well have been broken up in to model/controller/view hierarchies:

<pre><code>|-- features
|   |-- models
|   |   |-- entities
|   |   |   |-- entity.feature
|   |   |   `-- step_definitions
|   |   |       |-- anything.rb
|   |   |       `-- entity_steps.rb
|   |-- views
|   |   |   |-- entity_new
|   |   |   `-- step_definitions
|   |   |       `-- entity_new_steps.rb
|   |-- step_definitions
|   |   `-- webrat_steps.rb
|   `-- support
|       `-- env.rb
</code></pre>

Consider, however, that the cucumber feature generator will generate the files it produces in conformance with the default layout, with the <code>manage_frooble.feature</code> file placed in <code>./features</code> and the <code>frooble_steps.rb</code> file in <code>./features/step_definitions</code>. Also be aware that, regardless of the directory structure employed, cucumber effectively flattens the features directory tree when running tests.  By this I mean that anything ending in .rb under the start point for a cucumber feature run is searched for feature matches.  So that a step contained in <code>features/models/entities/step_definitions/anything.rb</code> can be used in a feature file contained in <code>features/views/entity_new</code>.  It is also worth noting that step files can be called anything so long as they end in <code>.rb</code>.  

h3. How do I Write Tests?

Constructing ones first tests, or features as BDD purists prefer, is often accompanied by what can only be described as <em>"writer's block":http://en.wikipedia.org/wiki/Writer%27s_block</em>.  While detailed discussion of feature writing and step construction are provided elsewhere (see [[Given-When-Then]] and "Telling a Good Story":http://blog.josephwilk.net/ruby/telling-a-good-story-rspec-stories-from-the-trenches.html), perhaps the easiest thing to do for the first time tester/behaviourist is to use cucumber's built-in generator to create a feature scaffold and then modify it.  
<pre><code>script/generate feature Frooble name color description
      exists  features/step_definitions
      create  features/manage_froobles.feature
      create  features/step_definitions/frooble_steps.rb
</code></pre>

While scaffolding provides a comforting illusion of progress through its voluminous production of template code, in practice it proves important to write each test/feature step <em><strong>one at a time</strong></em>.  After each new feature step is added then you should immediately create the corresponding step definition method.  Following the creation of the actual test/step definition that your new application should satisfy then you should write the minimal application code that gets the new test/step definition to pass before moving on to the next feature step.

It is often tempting to just <em>skip ahead</em> and complete as many scenarios and feature steps as one can imagine.  In some cases limited access to domain experts and end users may require that many feature steps be completed long before coding the associated step definitions is undertaken. Nonetheless, in the long run, it has proven best practice to write feature steps and step definitions incrementally, using the absolute minimum of code; and then immediately implement the new feature step requirement in application code, also using the minimum code to satisfy it.  This is a hard discipline to accept but the value is that with this approach you will rarely have untested code anywhere in your application and your application will only have code that satisfies required features.

If you do anticipate feature steps then omitting any matcher for them in the step definitions files causes these steps to be reported as <em>pending</em> in Cucumber 0.1.12.  Later versions of Cucumber may instead report missing matchers as missing and provide an explicit <strong><em>pending</em></strong> method to designate pending step definitions.

A single <strong><em>Feature</em></strong> is typically contained in its own file (ending in <code>.feature</code>).  Each Feature usually consists of multiple <strong><em>Scenarios</strong></em>.  Each Scenario consists of three sections, <strong>Given</strong>, <strong>When</strong> and <strong>Then</strong>.  Each section consists of one or more clauses (steps) that are used to match test step definitions. The conventional arrangement is:

<pre>Feature: Some terse yet descriptive text of what is desired
In order that some business value is realized
An actor with some explicit system role
Should obtain some beneficial outcome which furthers the goal
To Increase Revenue | Reduce Costs | Protect Revenue  (pick one)

  Scenario:   Some determinable business situation
      Given some condition to meet
         And some other condition to meet
       When some action by the actor
         And some other action
         And yet another action
       Then some testable outcome is achieved
         And something else we can check happens too

  Scenario:  A different situation
      ...
</code></pre>

For cucumber feature steps the key words used here are <strong>Feature</strong>, <strong>Scenario</strong>, <strong>Given</strong>, <strong>When</strong>, <strong>Then</strong>, and <strong>And</strong>.  Feature is used to provide identification of the test group when results are reported. Scenario is used in the same fashion.  Given, When, Then, and And are all cucumber <em><strong>methods</strong></em> that take as their argument the string that follows.  These are the steps that cucumber will report as passing, failing or pending based on the results of the corresponding step matchers in the step_definitions.rb files.  These four methods are also all equivalent.
<pre><code>
def Given(name)
  create_step('Given', name, *caller[0].split(':')[1].to_i)
end
def When(name)
  create_step('When', name, *caller[0].split(':')[1].to_i)
end
def Then(name)
  create_step('Then', name, *caller[0].split(':')[1].to_i)
end
def And(name)
  create_step('And', name, *caller[0].split(':')[1].to_i)
end
</code></pre>

The string argument from each of these methods is compared against all the matchers contained in the step_definitions.rb files.  A step definitions matcher looks much like this:
<pre><code>Given /there are (\d+) froobles/ do |n|
  Frooble.transaction do
    Frooble.destroy_all
    n.to_i.times do |n|
      Frooble.create! :name => "Frooble #{n}"
    end
  end
end
</code></pre>

The significant thing here is that the method (Given) takes as its argument a "regexp":http://en.wikipedia.org/wiki/Regexp bounded by  <code>/</code>.  For example, in the features provided above we had the statement: <code>And some other action</code>.  This could be matched by any of the following step definition matchers if present in any step_definitions.rb file found under the features root directory.
<pre><code>Given /some other action/ do
When /some (.*) action/ do |match|
Then /(*.) other action/ do |match|
Given /(.*) other (.*)/ do |first,second|
</code></pre>
But, this will throw a method missing exception:
<pre>
And /some other act.*/ do 
</pre>

The exception occurs because *_And_* is not defined as a steps definition method, but only as a feature step method.  The step definition match depends only upon the pattern following the Given/When/Then method and not upon the step method itself.  I have therefore adopted the practice of only using <code>When /I have a match/ do</code> in my step definitions files as *When* has a more natural appearance for a matcher.

If more than one matcher in all of the step definitions files matches a feature step then cucumber complains that it found multiple step definition matches for that step and forces you to distinguish them.

It is considered better form by some to surround with double quotation marks, <strong><code>" "</code></strong>, elements in the feature step clauses that are meant to be taken as values. This is only a convention and one not followed by many.  However, if you choose to follow this road then you must adjust your step definition matchers accordingly.  For example:
<pre><code>Given Some determinable "business" situation</code></pre>
<pre><code>Given /determinable "(.*)" situation/ do |s|</code></pre>

Finally, you can have step definitions call other step definitions, including those contained in other step definitions files.  For example:

<pre><code>When /some "(.*)" action/  do |a|
   ...
end

When /in an invoiced non-shipped situation/ do
  Given "some \"invoiced\" action" 
  Then "some \"non-shipped\" action"
  ...
end
</code></pre>

If one step definition calls another step definition then the matcher argument to the called <strong>Given/When/Then</strong> method must be enclosed with string delimiters.  Because of this, if you have adopted the practice of demarcating parameter values present in feature steps with double quotation marks then, you must escape these quotation marks when calling another definition_steps.rb matcher from inside a step_definitions.rb file.  You must take care not to include the quote marks in the step_definitions parameter matchers, for <code>"(.*)"</code> is not the same as <code>(.*)</code> or <code>(".*")</code>.  If you use quote delimited values in the .feature file steps and do not account for them in the corresponding step_definition.rb matcher regexp then you will obtain variables that contain leading and trailing quotes as part of their value.

<pre><code>
Scenario: Quotes surround value elements
  Given some "required" action

# step_definitions
When /some (.*) action/ do |a|
  a => "required"

When /some "(.*)" action/ do |a|
  a => required
</code></pre>

In a manner similar to my convention of using only using the *When* method for step definition matchers, since When, Given, and Then are all equivalent inside the step definitions file I have adopted the convention of calling other step definitions within matchers using the Then method, thus:

<pre>
When /my matcher named (.*)/ do |match|
  Then "my other matcher named \"#{match}\""
end

The choice of method has no impact on the result but, When and Then used in this fashion seem to me to read more naturally.

</pre>

h3. What Way do I Run the Tests?

Unless you are knowledgeable enough that you use "mocks and stubs":http://rspec.info/documentation/mocks/ then I consider it best to begin with creating a Rails migration file for the model you are testing ( or expressing features for ) followed by:<pre><code>rake db:migrate
rake db:test:prepare
</code></pre>

Testing with cucumber can be performed in several fashions.  Be aware that <code>Rake features</code>, <code>cucumber features</code>, and <code>autotest</code> with <code>ENV AUTOFEATURE=true</code> do not necessarily produce the same results given the same tests.  

Running <code>rake features</code> from the command line provides the easiest and most reliable method to run cucumber tests. The rake script provided with cucumber performs much of the background magic required to get the test database and requisite libraries properly loaded.  

Running cucumber directly from the command line requires the creation of a <code>cucumber.yml</code> file in the project root directory, even if that file remains empty.  When cucumber is run from the command line it is usually necessary to provide both the directory name containing the root directory of the tree containing feature files and the directory name containing references to the necessary library files.  In the typical project <code>cucumber features -r features</code> will normally suffice.  

Finally, running <code>autotest</code> with the environment variable <code>AUTOFEATURE=true</code> will run ALL tests, including those in <code>/test</code> and (if present) <code>/spec</code>.  As this will load all test fixtures the test database may be left in an indefinite state when cucumber features are run.  It is wise, as always, to write cucumber steps either so that they do not depend upon an empty database or they place the database in the requisite state.

h3. Anything Else?

The terminology for elements of Behaviour Driven Development differs somewhat from that employed by Test Driven Development.  This article, because of the introductory nature of its contents, tends to blur the semantic distinction between these two divergent philosophies.

Realize that tests/assertions/expectations either pass or fail (raise an error) and that fail is NOT the same as false, whereas anything but fail is a pass.  When, in RSpec, <code>something.should_be 0</code> and it is not, then what is returned is an error exception and not a boolean value.  In raw cucumber (pardon the pun) one writes <code>fail if false</code> and not simply <code>false</code>.  A little reflection reveals why this is so, since false might be the expected successful outcome of a test and thus not an error.  However, the distinction between fail and false escaped my notice until I was confronted with it in an actual test suite.

If you are testing with intent then you should be using the "ruby-debug gem":http://rubyforge.org/projects/ruby-debug/.  A really neat method to drop into an interactive debugging session _inside a cucumber step definition_ using ruby-debug was provided by "Scott Taylor on the rspec mailing list":http://www.ruby-forum.com/topic/175732#769713.  Just put these statements inside the step definition at the point that you wish to debug:  <code>require 'rubygems'; require 'ruby-debug'; debugger</code>.  When that code interrupts then type <code>irb</code> and you open an interactive debugging session wherein you can step forwards and backwards inside the code under test to determine exactly where the breakage is happening.  Alternatively, you can add <code>require 'rubygems'; require 'ruby-debug';</code> to your support/env.rb file (see below) and just put @debugger@ wherever you desire it inside any step definition.

Recall that cucumber is an <strong><em>"integration":http://en.wikipedia.org/wiki/Integration_testing</em></strong> test harness.  It is designed to exercise the entire application stack from view down to the database.  It is certainly possible to write features and construct step definitions in such a fashion as to conduct unit tests and no great harm will result.  However, this is not considered best practice by many and may prove insupportable for very large projects due to the system overhead it causes and the commensurate delay in obtaining test results.

Cucumber comes preconfigured for webrat together with webrat test steps.  If you do not know what webrat is and you are doing web application testing then you should "read about it":http://agilewebdevelopment.com/plugins/webrat.

If  webrat is installed in your rails project as a plugin then the webrat step definitions are available to you for functional/view tests "out of the box".  If, instead, you have "webrat":http://github.com/brynary/webrat/wikis installed as a gem and you wish to use the gem instead of a plugin then you may need add this to the features/support/env.rb file, although this may no longer be necessary with cucumber v-2.0+:

<code>require 'webrat' if !defined?(Webrat)</code>

Then, comment out these  in env.rb.
<pre><code># If webrat is a plugin then uncomment this
#require 'webrat/rails'

# Comment out the next two lines if you're not using RSpec's matchers (should / should_not) in your steps.
require 'cucumber/rails/rspec'
# If webrat is a plugin and rspec is used then uncomment this
#require 'webrat/rspec-rails'</code></pre>

Calls for any additional Ruby libraries that your particular testing environment may require are typically be placed in the <code>./features/support/local_env.rb</code> file.  I advise against putting local customization in <code>support/env.rb</code> as it is typically overwritten by <code>script/generate cucumber</code>.  As a matter of good practice you should always run <code>script/generate cucumber</code> whenever you install an updated version.  You should do the same for rspec as well.

Those of you that have used <code>growl</code> or <code>snarl</code> to provide desktop notifiers from autotest are advised that, as of this writing, cucumber did not hook into the :red :green notifier capability of autotest;  so, no popups when a step fails.  However, there exists a project to add a similar functionality to cucumber. See "Cucumber_Growler":http://github.com/paolodona/cucumber_growler/tree/master.

<code>autotest</code> is installed via the "ZenTest":http://www.zenspider.com/ZSS/Products/ZenTest/ gem.  If you use autotest then take a look at the contents of <code>example_dot_autotest.rb</code> in the ZenTest gem root directory.

h3.  Need Help?

The best place to go for help, that I know of, is the "RSpec Forum":http://www.ruby-forum.com/forum/32 at "Ruby-Forum.com":http://www.ruby-forum.com.  There you can find access to a number of forums and gateways to mailing lists that are related to Ruby and Ruby on Rails.

If you find a bug in cucumber then you should open a ticket at "Lighthouse":http://rspec.lighthouseapp.com/projects/16211-cucumber/ for it.

2008 November 28 - J. B. Byrne