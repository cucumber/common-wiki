h2. Or: How I Learned to Stop Worrying and Love Testing

h3. Introduction

This document deals principally with initial set up and first use of the <strong><em> Cucumber-Rails</em></strong> gem, that uses <strong><em>Cucumber</em></strong>, a behaviour driven development (BDD) tool, for designing and implementing a project using the Ruby on Rails (RoR) framework.  Discussion of "Behaviour Driven":http://en.wikipedia.org/wiki/Behavior_driven_development, "Test Driven":http://en.wikipedia.org/wiki/Test-driven_development (TDD), and "Panic Driven Development":http://en.wikipedia.org/wiki/SNAFU (SNAFU aka "Cowboy Coding":http://en.wikipedia.org/wiki/Cowboy_coding) can be found elsewhere.  Details regarding installing the Cucumber gem and its recommended support tools for RoR are found on this wiki under the heading  [[Ruby on Rails]].  The article "Getting Started with Rails":http://www.ultrasaurus.com/code/2008/12/getting-started-with-rails.html is a useful introductory tutorial dealing with Rails and Cucumber.

Since the original version of this article appeared, Cucumber has undergone repeated revisions and refactorings.  Among these was the sensible decision to move portions of the implementation specific to particular frameworks into their own gems.  Consequently, installing Cucumber for a framework now frequently starts with installing the specific framework Cucumber gem, which in turn pulls in the core Cucumber gem as a dependency.  Cucumber now provides support for a wide range of Ruby VMs such as JRuby, alternative application frameworks such as Sinatra, other programming languages such as Python, test environments such as Capybara, and provides i18n language support for feature and step files.  Obtaining these features may require the installation of other gems such as "cucumber-sinatra":http://rubygems.org/gems/cucumber-sinatra.

Readers should always consider that the information contained herein may be out of date and therefore incomplete or erroneous in some respects.  However, any such defects will usually be confined to specific implementation details and should not detract from the validity of the overall presentation.

Note that in this document I often use the terms <em>testing</em> and <em>test</em> where "BDD practitioners":http://dannorth.net/introducing-bdd prefer the terms <em>behaviour</em> and <em>expectation</em>.  When I use the word test in a BDD context I am in fact discussing expressing and verifying expected behaviour.

h3. Where to Start?

<pre>
Feature: Design and Build a Ruby on Rails web app using Behaviour Driven Development (BDD)
In order to reduce rework and produce a web app at low cost and high speed
A developer 
Should employ a BDD methodology and agile tools

Scenario: Cucumber should be installed and configured
Given I have installed the gem named "rails"
  And I have installed the gem named "cucumber-rails"
  And I have generated a RoR project named "my_project"
  And the present working directory is the Rails root directory of "my_project"
  And I have the file cucumber.yml in the config directory of "my_project"
  And the file cucumber.yml contains a valid default profile

When I run "script/generate cucumber"

Then I should create the directory ./features
  And I should create the file ./features/features.feature
  And I should create the directory ./features/step_definitions
  And I should create the file ./features/step_definitions/web_steps.rb
  And I should create the directory ./features/support
  And I should create the file ./features/support/env.rb
  And I should create the file ./features/support/paths.rb
  And I should create the file ./lib/tasks/cucumber.rake
  And I should create the file ./config/environments/environment cucumber.rb
  And I should create the file ./config/cucumber.yml
  And I should modify ./config/database.yml
  .  .  .
</pre>

The foregoing gives a sample of the form that feature files often take.  The statements, called <em>feature steps</em>, make up the user interface to Cucumber testing.  These here are written in the "Imperative Style":http://www.benmabey.com/2008/05/19/imperative-vs-declarative-scenarios-in-user-stories/ for illustrative purposes.  In practice, all those Then/And statements likely would be subsumed into one simple Declarative statement; for example: <code>I should create the Cucumber environment</code>, and the messy details of just what a Cucumber environment should comprise placed in the step definitions instead. We will return to that topic later.  For the moment we deal with the logical arrangement of Cucumber files within the context of a RoR project.

The root level of the archetypal RoR project directory tree looks like this:

<pre><code>MyProject
|-- README
|-- Rakefile
|-- app
|-- config
|-- db
|-- doc
|-- lib
|-- log
|-- public
|-- script
|-- test
|-- tmp
`-- vendor
</code></pre>

Running script/generate cucumber adds this layout to the existing structure:
<pre><code>|-- features
|-- step_definitions
|   `-- web_steps.rb
`-- support
    |-- env.rb
    |-- hll_cuke_sample_helpers.rb
    `-- paths.rb
</code></pre>

We are now ready to begin testing with Cucumber.

h3.  Where do I put Tests?

Cucumber divides testing into two parts, the outward facing feature <em>steps</em> and the inward facing <em>step definitions</em>.  As discussed elsewhere, [[Feature Introduction|features]] are descriptions of desired outcomes (<strong>Then</strong>) following upon specific events (<strong>When</strong>) under predefined conditions (<strong>Given</strong>).  They are typically used in conjunction with end-user input and, in some cases, may be entirely under end-user (in the form of a domain expert) control. Feature files are given the extension <code>.feature</code>.  

A source of potential confusion is that the term <em><strong>steps</strong></em>, when used loosely, has two, closely related but vitally distinct, meanings depending on context.  Inside feature.feature files, steps are the textual descriptions which form the body of a scenario.  These are prefaced with the keywords Given, When, Then, And or But (note as well that the capitalization of these five names is significant).  Inside a step_definitions.rb file, steps (which strictly speaking should always be called step definitions) refers to the <em>matcher</em> methods, which may be given any of the same names (Given, When, Then, And or But),  each provided with a matcher regexp that corresponds to one or more feature steps.  Note that the method name does NOT form part of the matcher.  A Given feature clause can match a When step definition matcher.  Over time, clauses from features have come to be referred to simply as <em>features</em> while <em>steps</em> now refers almost exclusively to step definitions.

[[step definitions|Step definitions]], keyed by their snippets of text from the feature scenario statements, invoke blocks of Ruby and Rails code that usually contains assertion statements from whatever test system you have installed.  Given that Cucumber evolved out of RSpec stories it is unsurprising that the Cucumber generator once assumed that RSpec was available.  This has long since ceased to be the case.  What Cucumber does now is detect if the rspec and rspec-rails gems are installed.  If so then the rails generator builds the environment files to suit and if not then it ignores rspec and configures for test-unit instead.  Further, the availability of Cucumber generator options is increasing over time.  To see what is available in the version of Cucumber-Rails that you have installed use the command: <code>script/generate cucumber --help</code>.

As detailed above, the default features directory tree is fairly shallow.  One can put every feature into a single file in the features directory and every step in a single file in the steps_definition directory (or even in the features directory itself) if one so chooses.  One can choose to have one or more feature files for each feature together with one or more step files for each feature file; or any combination thereof.  However, Cucumber is programmed with the flexibility to support a much more expressive directory structure.  For instance:

<pre><code>|-- features
|   |-- entities
|   |   |-- entity.feature
|   |   `-- step_definitions
|   |       |-- anything.rb
|   |       `-- entity_steps.rb
|   |-- locations
|   |   |-- location.feature
|   |   `-- step_definitions
|   |       `-- location_steps.rb
|   |-- sites
|   |   `-- step_definitions
|-- step_definitions
|   |-- local_assert_steps.rb
|   |-- local_crud_response_steps.rb
|   |-- local_email_steps.rb
|   |-- local_file_steps.rb
|   |-- local_script_steps.rb
|   |-- local_steps.rb
|   |-- local_web_steps.rb
|   |-- local_xml_file_steps.rb
|   `-- web_steps.rb
`-- support
    |-- env.rb
    |-- hll_cuke_sample_helpers.rb
    |-- local_env.rb
    `-- paths.rb

</code></pre>

In this case the bland initial setup has been divided into sub-directories informed by model-centric testing.  This could equally well have been broken up in to model/controller/view hierarchies:

<pre><code>|-- features
|   |-- models
|   |   |-- entities
|   |   |   |-- entity.feature
|   |   |   `-- step_definitions
|   |   |       |-- anything.rb
|   |   |       `-- entity_steps.rb
|   |-- views
|   |   |-- entity_new
|   |   `-- step_definitions
|   |       `-- entity_new_steps.rb
|-- step_definitions
|   |-- local_steps.rb
|   `-- web_steps.rb
`-- support
      |-- env.rb
      |-- hll_cuke_sample_helpers.rb
      |-- local_env.rb
       `-- paths.rb
</code></pre>

Consider, however, that the Cucumber feature scaffold generator will generate the files it produces in conformance with the default layout, with the <code>manage_frooble.feature</code> file placed in <code>./features</code> and the <code>frooble_steps.rb</code> file in <code>./features/step_definitions</code>. Also be aware that, regardless of the directory structure employed, Cucumber effectively flattens the features directory tree when running tests.  By this I mean that anything ending in .rb under the start point for a Cucumber feature run is searched for feature matches.  So that a step contained in <code>features/models/entities/step_definitions/anything.rb</code> can be used in a feature file contained in <code>features/views/entity_new</code>, providing that cucumber is invoked on a root directory common to both, <code>./features</code> in this case; or explicitly required on the command line, <code>$ cucumber -r ./features features/views/entity_new</code>.  It is also worth noting that step files can be called anything so long as they end in <code>.rb</code>.  

h3. How do I Write Tests?

Constructing ones first tests, or features as BDD purists prefer, is often accompanied by what can only be described as <em>"writer's block":http://en.wikipedia.org/wiki/Writer%27s_block</em>.  While detailed discussion of feature writing and step construction are provided elsewhere (see [[Given-When-Then]] and "Telling a Good Story":http://blog.josephwilk.net/ruby/telling-a-good-story-rspec-stories-from-the-trenches.html), perhaps the easiest thing to do for the first time tester/behaviourist is to use Cucumber's built-in generator to create a feature scaffold and then modify it.  
<pre><code>script/generate feature Frooble name color description
      exists  features/step_definitions
      create  features/manage_froobles.feature
      create  features/step_definitions/frooble_steps.rb
</code></pre>

While scaffolding provides a comforting illusion of progress through its voluminous production of template code, in practice it proves important to write each test/feature step <em><strong>one at a time</strong></em>.  After each new feature step is added then you should immediately create the corresponding step definition method.  After creating your new test/step definition you must prove to yourself that it fails by running it against the, as yet, non-existent application code.  Then, and only then, should you write the least application code that gets your test/step definition to pass.  Once this cycle is complete then move on to the next feature step.

It is often tempting to just <em>skip ahead</em> with the analysis and complete as many scenarios and feature steps as one can imagine.  In some cases limited access to domain experts and end users may require that many feature steps be completed long before coding the associated step definitions is undertaken. Nonetheless, in the long run, it has proven best practice to write feature steps and step definitions incrementally, using the absolute minimum of code; and then immediately implement the new feature step requirement in application code, also using the minimum code to satisfy it.  

This is a hard discipline to accept but the value with this approach is that you will rarely (never) have untested code anywhere in your application and your application will only have code that satisfies required features.  Consequently, you can face design changes with complete equanimity, secure in the knowledge that if unanticipated changes break anything else then you will know of the side-effect immediately upon running your test suite.

If you do anticipate feature steps then omitting any matcher for them in the step definitions files causes these steps to be reported as missing by Cucumber, which helpfully provides a suggested method and argument to implement.  Stub step matchers have an explicit <strong><em>pending</em></strong> method available to designate defined but pending/undefined step definitions.

h3. What are Features and Scenarios?

A feature can be conceptualized as an indivisible unit of functionality embedded in the project to which it belongs.  For example, an authentication challenge and response user interface is usually considered a feature while an authentication system would comprise many features.   A single <strong><em>Feature</em></strong> is typically contained in its own file (ending in <code>.feature</code>).  Each Feature usually consists of multiple <strong><em>Scenarios</strong></em>.

A scenario is a block of instructions that exercise some behaviour desired or depreciated in the feature to which it belongs.  A scenario might check that the login interface provides input fields for the requisite responses, that failures are logged or otherwise reported. that user ids are locked out after a given number of failed attempts, and so forth.  Each scenario exercises the implementation code  to prove that for each anticipated condition the expected behaviour is indeed produced.

Each Scenario consists of three sections, <strong>Given</strong>, <strong>When</strong> and <strong>Then</strong>.  Each section consists of one or more clauses (steps) that are used to match test step definitions. The conventional arrangement is:

<pre>Feature: Some terse yet descriptive text of what is desired
In order that some business value is realized
An actor with some explicit system role
Should obtain some beneficial outcome which furthers the goal
To Increase Revenue | Reduce Costs | Protect Revenue  (pick one)

  Scenario:   Some determinable business situation
      Given some condition to meet
         And some other condition to meet
       When some action by the actor
         And some other action
         And yet another action
       Then some testable outcome is achieved
         And something else we can check happens too

  Scenario:  A different situation
      ...
</code></pre>

For Cucumber features the key words used here are <strong>Feature</strong>, <strong>Scenario</strong>, <strong>Given</strong>, <strong>When</strong>, <strong>Then</strong>, and <strong>And</strong>.  Feature is used to provide identification of the test group when results are reported. Scenario is used in the same fashion.  Given, When, Then, And and But are all Cucumber <em><strong>methods</strong></em> that take as their argument the string that follows.  These are the steps that Cucumber will report as passing, failing or pending based on the results of the corresponding step matchers in the step_definitions.rb files.  These five methods are also all equivalent.

The string argument from each of these methods is compared against all the matchers contained in the step_definitions.rb files.  A step definitions matcher looks much like this:
<pre><code>Given /there are (\d+) froobles/ do |n|
  Frooble.transaction do
    Frooble.destroy_all
    n.to_i.times do |n|
      Frooble.create! :name => "Frooble #{n}"
    end
  end
end
</code></pre>

The significant thing here is that the method (Given) takes as its argument a "regexp":http://en.wikipedia.org/wiki/Regexp bounded by  <code>/</code>.  Among other things, that means that all the arguments are received as string values.  Thus <code>n.to_i.times</code> and not simply <code>n.times</code>.

In the features provided above we had the statement: <code>And some other action</code>.  This could be matched by any of the following step definition matchers if present in any step_definitions.rb file found under the features root directory.
<pre><code>Given /some other action/ do
When /some (.*) action/ do |match|
Then /(*.) other action/ do |match|
Given /(.*) other (.*)/ do |first,second|
But /(.*) other (.*)/ do |first,second|
And /(.*) other (.*)/ do |first,second|
</code></pre>

The step definition match depends only upon the pattern following the Given/When/Then method and not upon the step method itself.  I have therefore adopted the practice of only using <code>When /I have a match/ do</code> in my step definitions files as *When* has a more natural appearance, to me, for a matcher.

If more than one matcher in all of the step definitions files matches a feature step then Cucumber complains that it found multiple step definition matches for that step and forces you to distinguish them.  You can force Cucumber to make a decision instead by passing the switch <code>--guess</code> on the command line.

It is considered better form by some to surround with double quotation marks, <strong><code>" "</code></strong>, all elements in the feature step clauses that are meant to be taken as values. This is only a convention and one not followed by many.  However, if you choose to follow this road then you must adjust your step definition matchers accordingly.  For example:
<pre><code>Given Some determinable "business" situation</code></pre>
<pre><code>Given /determinable "(.*)" situation/ do |s|</code></pre>

Finally, you can have step definitions call other step definitions, including those contained in other step definitions files.  For example:

<pre><code>When /some "(.*)" action/  do |a|
   ...
end

When /in an invoiced non-shipped situation/ do
  Given "some \"invoiced\" action" 
  Then "some \"non-shipped\" action"
  ...
end
</code></pre>

If one step definition calls another step definition then the matcher argument to the called <strong>Given/When/Then</strong> method must be enclosed with string delimiters.  Because of this, if you have adopted the practice of demarcating parameter values present in feature steps with double quotation marks, you must escape these quotation marks when calling another definition_steps.rb matcher from inside a step_definitions.rb file.  You must take care not to include the quote marks in the step_definitions parameter matchers, for <code>"(.*)"</code> is not the same as <code>(.*)</code> or <code>(".*")</code>.  If you use quote delimited values in the .feature file steps and do not account for them in the corresponding step_definition.rb matcher regexp then you will obtain variables that contain leading and trailing quotes as part of their value.

<pre><code>
Scenario: Quotes surround value elements
  Given some "required" action

# step_definitions
When /some (.*) action/ do |a|
  a => "required"

When /some "(.*)" action/ do |a|
  a => required
</code></pre>

In a manner similar to my convention of using only using the *When* method for step definition matchers, as When, Given, and Then are all equivalent inside the step definitions file, I have adopted the convention of calling other step definitions within matchers using the Then method, thus:

<pre>
When /my matcher named (.*)/ do |match|
  Then "my other matcher named \"#{match}\""
end
</pre>

The choice of method has no impact on the result but, <em>When</em> and <em>Then</em> used in this fashion seem to me to read more naturally.  You should also realize that the argument passed to the <em>Then</em> method is a string and that the string may be constructed in any manner.  For example the above <em>Then</em> statement could be passed as: 

<pre>
When /my matcher named (.*)/ do |match|
  Then %Q(my other matcher named "#{match}")
end
</pre>

This latter format removes the necessity to escape (\) the embedded quotation characters (").  Multiple steps may be called using the <em>steps</em> method which itself takes a string argument:

<pre>
When /my matcher named (.*)/ do |match|
  steps %Q{
    Then my other matcher named "#{match}"
     And the next matcher with value "{match}"
  }
end
</pre>

Keep in mind that cucumber is simply a DSL wrapper around the Ruby language, whose full expressiveness remains available to you in the step definition files.

If all your feature's scenarios share the same 'setup' feature steps then Cucumber provides the <em>Background</em> section.  Steps contained within a Background section are run before each of the scenarios.

<pre>
Feature: .  .  .
  Background: .  .  .
  Scenario: .  .  .
</pre>  

h3. What are "tags"?

Cucumber provides a simple method to organize features and scenarios by user determined classifications.  This is implemented using the convention that any space delimited string found in a feature file that is prefaced with the commercial at (<strong>&#64;</strong>) symbol is considered a tag.  As distributed, Cucumber-Rails builds a Rake task that recognizes the <em>&#64;wip</em> tag.  However, any string may used as a tag and any scenario or entire feature can have multiple tags associated with it.  For example:

<pre>
  @init
  Feature:  .  .  .
  .  .  .
  @wip @authent
  Scenario:  A user should authenticate before accessing any resource.
     Given we do have a user named "testuser"
      When I visit "the login page"
         And I enter "testuser" in the "User ID" field
         .   .  .
</pre> 

Given that the forgoing is contained in a file called <code>features/login/login.feature</code> and that the cucumber-rails gem is installed and configured then you can exercise this scenario, along with any others that are similarly tagged, in any of the following ways:

<pre>
$ rake cucumber:wip
$ cucumber --profile=my_profile --tags=@wip features
$ cucumber --profile=my_profile --tags=@authent features/login
$ cucumber --profile=my_profile --tags=@init 
</pre>

However, the following will not work, unless you build a custom rake task for it:

<pre>
$ rake cucumber:authent
</pre>

There is an obscure <em>gotcha</em> with this particular combination of tags.  The default profile contained in the distributed <code>config/cucumber.yml</code> contains these lines:

<pre>
<%
.  .  .
std_opts = "--format #{ENV['CUCUMBER_FORMAT'] || 'progress'} --strict --tags ~@wip"
%>
default: <%= std_opts %> features
.  .  .
</pre>

Note the trailing option <code>--tags ~@wip</code>.  If you do not specify a different profile then the default profile will
be used.  If this is used then the <code>--tags ~@wip</code> will ignore any scenario that is so tagged.  This will override the <code>--tags=@authen</code> option passed in the command line and so you will see this:

<pre>
$ cucumber --tags=@authent
Using the default profile...

0 scenarios
0 steps
0m0.000s
</pre>

The number of occurrences of a particular tag in your feature set may be controlled by appending an optional count to the end of the tag name passed to the tags option, as in <code>$ cucumber --tags=@wip:3 features/log*</code>.  The existence of more than the specified number of occurrences of that tag in all the features that are exercised during a particular cucumber run will produce a warning message. 

Limiting the number of occurrences is commonly used in conjunction with the &#64;wip tag to restrict the number of unspecified scenarios to manageable levels.  Those following "Kanban":http://en.wikipedia.org/wiki/kanban or "Lean Software Development":http://en.wikipedia.org/wiki/Lean_software_development based methodologies will find this facility invaluable.

As encountered above in the default profile, tags may be negated by prefacing the tag with the tilde (<strong>~</strong>) symbol.  In other words, you can exclude all scenarios that have a particular tag.  For example, the following will only exercise all scenarios found in the directory tree rooted at <code>features/wip</code> that do not have the tag <em>&#64;ignore</em>:

<pre>
$ cucumber --require=features --tag=~@ignore features/wip
</pre>

h3. What Way do I Run the Tests?

Unless you are knowledgeable enough that you use "mocks and stubs":http://rspec.info/documentation/mocks/ then I consider it best to begin with creating a Rails migration file for the model you are testing ( or expressing features for ) followed by:
<pre><code>rake db:migrate
rake db:test:prepare
</code></pre>

However, there is an important environmental consideration to keep in mind when using an actual database for testing: Cucumber, by default, uses database transactions and these transactions are rolled back after each scenario.  This makes out-of-process testing problematic (for that see the Cucumber "Aruba":http://github.com/aslakhellesoy/aruba project)  and may result in some unanticipated outcomes under certain scenarios.  Transactions can be turned off, but then your features become responsible for ensuring that the database is in a condition suitable for testing.  Cucumber provides hooks to accomplish this and the gem "Database-Cleaner":http://github.com/bmabey/database_cleaner is configured in support/env.rb to assist. 

Testing with Cucumber can be performed in several fashions.  Be aware that <code>rake cucumber</code>, <code>cucumber features</code>, and <code>autotest</code> with <code>ENV AUTOFEATURE=true</code> do not necessarily produce the same results given the same features and step definitions.  

Running <code>rake cucumber</code> from the command line provides the simplest, if not the speediest, method to run Cucumber tests. The rake script provided with cucumber performs much of the background magic required to get the test database and requisite libraries properly loaded.  As discussed above, the Cucumber Rake task recognises the <code>@wip</code> tag, so <code>rake cucumber:wip</code> will run only those scenarios tagged with <strong>&#64wip</strong>.  For example, given a feature file containing:

<pre>
Feature: .  .  .

  Scenario: A

  @wip
  Scenario: B

  Scenario: C
</pre>

running the command <code>rake cucumber:wip</code> will run the steps contained inside Scenario B only, while running <code>rake cucumber:ok</code> will run the steps within all Scenarios other than B.

Cucumber-Rails creates a <code>cucumber.yml</code> file in the project config directory containing a number of predefined profiles, one of which is the default profile.  When Cucumber is run from the command line it is usually necessary to provide both the directory name containing the root directory of the tree containing feature files and the directory name containing references to the necessary library files.  In the typical project <code>cucumber features -r features</code> will normally suffice.  Repetitious usages can be added to user defined profiles contained in the project's <code>cucumber.yml</code> file.

Finally, running <code>autotest</code> with the environment variable <code>AUTOFEATURE=true</code> will run ALL tests, including those in <code>/test</code> and (if present) <code>/spec</code>.  As this will load all test fixtures the test database may be left in an indefinite state when Cucumber features are run.  It is wise, as always, to write Cucumber steps either so that they do not depend upon an empty database or they place the database in the requisite state.

h3. Anything Else?

The terminology for elements of Behaviour Driven Development differs somewhat from that employed by Test Driven Development.  This article, because of the introductory nature of its contents, tends to blur the semantic distinction between these two divergent philosophies.

Cucumber is evolving, rapidly.  This article is revised to Cucumber version 0.8.4 and Cucumber-Rails version 0.3.2 but it does not cover many of the new attributes of Cucumber and Cucumber-Rails.  The essentials of this article remain applicable throughout all the variants of Cucumber and Cucumber-Rails but the implementation details may have changed.  It would not be wise to use this article as a recipe.

If you are testing with intent then you should be using the "ruby-debug gem":http://rubyforge.org/projects/ruby-debug/.  A really neat method to drop into an interactive debugging session _inside a Cucumber step definition_ using ruby-debug was provided by "Scott Taylor on the rspec mailing list":http://www.ruby-forum.com/topic/175732#769713.  Just put these statements inside the step definition at the point that you wish to debug:  <code>require 'rubygems'; require 'ruby-debug'; debugger</code>.  When that code interrupts then type <code>irb</code> and you open an interactive debugging session wherein you can step forwards and backwards inside the code under test to determine exactly where the breakage is happening.  Alternatively, you can add <code>require 'rubygems'; require 'ruby-debug';</code> to your <code>support/local_env.rb</code> file (see below) and just put @debugger@ wherever you desire it inside any step definition.

Realize that tests/assertions/expectations either pass or fail (raise an error) and that fail is NOT the same as false, whereas anything but fail is a pass.  When, in RSpec, <code>something.should_be 0</code> and it is not, then what is returned is an error exception and not a Boolean value.  In raw Cucumber (pardon the pun) one writes <code>fail if false</code> and not simply <code>false</code>.  A little reflection reveals why this is so, since false might be the expected successful outcome of a test and thus not an error.  However, the distinction between fail and false escaped my notice until I was confronted with it in an actual test suite.

Recall that Cucumber is an <strong><em>"integration":http://en.wikipedia.org/wiki/Integration_testing</em></strong> test harness.  It is designed to exercise the entire application stack from view down to the database.  It is certainly possible to write features and construct step definitions in such a fashion as to conduct unit tests and no great harm will result.  However, this is not considered best practice by many and may prove insupportable for very large projects due to the system overhead it causes and the commensurate delay in obtaining test results.

Cucumber-Rails is pre-configured with support for view integration testing using either "Capybara":http://github.com/jnicklas/capybara (script/generate  cucumber --capybara) or "Webrat":http://github.com/brynary/webrat (script/generate cucumber).  If you do not know what Capybara or Webrat are or do,  and you are doing web application testing, then you should find out more about both.  The Cucumber-Rails generator will set up the necessary support files for whichever you choose. 

While Capybara is emerging as the preferred testing method it does not play well with Rails' 2.x own built-in Test Assertions.  In particular, whenever Capybara is required into a Cucumber World then the response.body method of Rails Test::Unit seems to disappear.  

Calls for any additional Ruby libraries that your particular testing environment may require are typically placed in the <code>./features/support/local_env.rb</code> file.  I advise against putting local customization in <code>support/env.rb</code> as it is typically overwritten by <code>script/generate cucumber</code>.  As a matter of good practice you should always run <code>script/generate cucumber</code> whenever you install an updated version.  You should do the same for rspec as well.

Those of you that have used <code>growl</code> or <code>snarl</code> to provide desktop notifiers from autotest are advised that, as of this writing, Cucumber did not hook into the :red :green notifier capability of autotest;  so, no pop-ups when a step fails.  However, there exists a project to add a similar functionality to Cucumber. See "Cucumber_Growler":http://github.com/paolodona/cucumber_growler/tree/master.

<code>autotest</code> is installed via the "ZenTest":http://www.zenspider.com/ZSS/Products/ZenTest/ gem.  If you use autotest then take a look at the contents of <code>example_dot_autotest.rb</code> in the ZenTest gem root directory.

h3.  Need Help?

The best place to go for help, that I know of, is the "Google Cucumber Group":http://groups.google.com/group/cukes.

If you find a bug in Cucumber, or wish a new feature added, then you should open a ticket at "Lighthouse":http://rspec.lighthouseapp.com/projects/16211-cucumber/ for it.

2008 November 28 - J. B. Byrne initial
2010 January 17 - J. B. Byrne revised to 0.6.1
2010 May 28 - J. B. Byrne revised 0.7.3
2010 July 13 - J. B. Byrne revised to 0.8.4

h3. Postscript.

A caution, Cucumber is meant to facilitate expressing required behaviours.  Indirection and excessive adherence to the principle of DRY, particularly in features, is at variance with both the intent and the major benefit of the tool.  Requirement expression in features should remain as self evident to the non-technical reader and be as self contained as possible.  Resist the temptation to effectively program features using the DSL.  Features should remain patent statements of intent.  If you feel the need to "program" in order to simplify writing a feature then you are likely doing something at considerably at odds with the intent of BDD methodology.
