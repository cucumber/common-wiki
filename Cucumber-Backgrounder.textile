h2. Or: How I Learned to Stop Worrying and Love Testing

h3. Introduction

This discussion deals principally with the initial set up and use of cucumber features in a Ruby on Rails (RoR) Project.  Discussion of "Behaviour Driven":http://en.wikipedia.org/wiki/Behavior_driven_development (BDD), "Test Driven":http://en.wikipedia.org/wiki/Test-driven_development (TDD), and "Panic Driven Development":http://en.wikipedia.org/wiki/SNAFU (SNAFU) (aka "Cowboy Coding":http://en.wikipedia.org/wiki/Cowboy_coding) can be found elsewhere.  Details regarding installing the Cucumber gem and its recommended support tools for RoR are found at [[Ruby on Rails]].

h3. Where to Start?

<pre>Given that you have installed the gem called "Cucumber"
  And you have generated a RoR project called "MyProject"
  And your session's working directory is called "MyProject"

When you run "script/generate cucumber"

Then you will create a sub-directory called "features"
</pre>

The foregoing is written in the style of the feature statements, called <em>steps</em>, that make up the user interface to cucumber testing.  We will return to that topic later.  For the moment we deal with the logical arrangement of cucumber files within the context of a RoR project.

The root level of the archetypal RoR project directory tree looks like this:

<pre><code>MyProject
|-- README
|-- Rakefile
|-- app
|-- config
|-- db
|-- doc
|-- lib
|-- log
|-- public
|-- script
|-- test
|-- tmp
`-- vendor
</code></pre>

Running script/generate cucumber adds this layout to the existing structure:
<pre><code>|-- features
|   |-- step_definitions
|   |   `-- webrat_steps.rb
|   `-- support
|       `-- env.rb
</code></pre>

We are now ready to begin testing with cucumber.

h3.  Where do I put Tests?

Cucumber divides testing into two parts, the outward facing feature <em>steps</em> and the inward facing <em>step definitions</em>.  As discussed elsewhere, [[Feature Introduction|features]] are descriptions of desired outcomes (<strong>Then</strong>) following upon specific events (<strong>When</strong>) under predefined conditions (<strong>Given</strong>).  They are typically used in conjunction with end-user input and, in some cases, may be entirely under end-user (in the form of a domain expert) control. Feature files are given the extension <code>.feature</code>.  

A source of potential confusion is that the term <em><strong>steps</strong></em>, when used loosely, has two, closely related but vitally distinct, meanings depending on context.  Inside <code>.feature</code> files, steps are the textual descriptions which form a scenario.  These are prefaced with Given, When, Then, and And (note as well that the capitalization of these four keywords/method names is significant).  Inside a step_definitions.rb file, steps (which strictly speaking should always be called step definitions) refers to the <em>matcher</em> methods, given exactly the same names (Given, When, Then, or And),  each provided with a matcher regexp that corresponds to one or more feature steps.

[[Step Organisation|Step definitions]], keyed by their snippets of text from the feature files, invoke blocks of ruby and rails code that usually contains assertion statements from whatever test system you have installed.  Given that cucumber evolved out of RSpec stories it is unsurprising that the cucumber generator assumes that rspec is available, as is evidenced in the default contents of <code>features/support/env.rb</code>:

<pre><code># Sets up the Rails environment for Cucumber
ENV["RAILS_ENV"] = "test"
require File.expand_path(File.dirname(__FILE__) + '/../../config/environment')
require 'cucumber/rails/world'
Cucumber::Rails.use_transactional_fixtures

# Comment out the next line if you're not using 
# RSpec's matchers (should / should_not) in your steps.
require 'cucumber/rails/rspec'
</code></pre>

You are not limited to this testing framework however.  If you choose to use Rails built-in TestUnit, or any other testing suite, then you may do that by extending the cucumber working environment as explained in [[Using Test::Unit]].

As detailed above, the default features directory tree is fairly shallow.  One can put every feature into a single file in the features directory and every step in a single file in the steps_definition directory (or even in the features directory itself) if one so chooses.  One can choose to have one or more feature files for each feature together with one or more step files for each feature file; or any combination thereof.  However, cucumber is programmed with the flexibility to support a much more expressive directory structure.  For instance:

<pre><code>|-- features
|   |-- entities
|   |   |-- entity.feature
|   |   `-- step_definitions
|   |       |-- anything.rb
|   |       `-- entity_steps.rb
|   |-- locations
|   |   |-- location.feature
|   |   `-- step_definitions
|   |       `-- location_steps.rb
|   |-- sites
|   |   `-- step_definitions
|   |-- step_definitions
|   |   `-- webrat_steps.rb
|   `-- support
|       `-- env.rb
</code></pre>

In this case the bland initial setup has been divided into sub-directories informed by model-centric testing.  However this could equally well have been broken up in to model/controller/view hierarchies:

<pre><code>|-- features
|   |-- models
|   |   |-- entities
|   |   |   |-- entity.feature
|   |   |   `-- step_definitions
|   |   |       |-- anything.rb
|   |   |       `-- entity_steps.rb
|   |-- views
|   |   |   |-- entity_new
|   |   |   `-- step_definitions
|   |   |       `-- entity_new_steps.rb
|   |-- step_definitions
|   |   `-- webrat_steps.rb
|   `-- support
|       `-- env.rb
</code></pre>

Consider, however, that the cucumber feature generator will generate the files it produces in conformance with the default layout, with the <code>manage_frooble.feature</code> file placed in <code>./features</code> and the <code>frooble_steps.rb</code> file in <code>./features/step_definitions</code>. Also be aware that, regardless of the directory structure employed, cucumber effectively flattens the features directory tree when running tests.  By this I mean that anything ending in .rb under the start point for a cucumber feature run is searched for feature matches.  So that a step contained in <code>features/models/entities/step_definitions/anything.rb</code> can be used in a feature file contained in <code>features/views/entity_new</code>.  It is also worth noting that step files can be called anything so long as they end in <code>.rb</code>.  

h3. How do I Write Tests?

Constructing ones first tests, or features as BDD purists prefer, is often accompanied by what can only be described as <em>"writer's block":http://en.wikipedia.org/wiki/Writer%27s_block</em>.  While detailed discussion of feature writing and step construction are provided elsewhere ([[Given-When-Then]]), perhaps the easiest thing to do for the first time tester/behaviourist is to use cucumber's built-in generator to create a feature scaffold and then modify it.  
<pre><code>script/generate feature Frooble name color description
      exists  features/step_definitions
      create  features/manage_froobles.feature
      create  features/step_definitions/frooble_steps.rb
</code></pre>

However, in practice it proves important to write each test/feature step <em><strong>one at a time</strong></em>.  After each feature step is added then you should immediately create the corresponding step definition method.  Following the creation of the actual test/step definition that your new application should satisfy then you should write the minimal application code that gets the new test/step definition to pass before moving on to the next feature step. 

It is tempting to just <em>skip ahead</em>, particularly with features.  In some cases limited access to domain experts and end users may require that many feature steps be completed long before coding the associated step definitions is undertaken. Nonetheless, in the long run, it has proven best practice to write features and step definitions incrementally, using the absolute minimum of code; and then immediately implement the new feature step requirement in application code, also using the minimum code to satisfy it.  This is a hard discipline to accept but the value is that with this approach you will rarely have untested code anywhere in your application and your application will only have code that satisfies required features.

If you do anticipate feature steps then omitting any matcher for them in the step definitions files causes these steps to be reported as <em>pending</em>.

A <strong><em>Feature</em></strong> is typically contained in its own file (ending in <code>.feature</code>).  Each Feature consists of multiple <strong><em>Scenarios</strong></em>.  Each Scenario consists of three sections, <strong>Given</strong>, <strong>When</strong> and <strong>Then</strong>.  Each section consists of one or more clauses (steps) that are used to match test step definitions. The conventional arrangement is:

<pre>Feature: Some terse yet descriptive text of what is desired
In order that some business value is realized
An actor with some explicit system role
Should obtain some beneficial outcome which furthers the goal
To Increase Revenue | Reduce Costs | Protect Revenue  (pick one)

  Scenario:   Some determinable business situation
      Given some condition to meet
         And some other condition to meet
       When some action by the actor
         And some other action
         And yet another action
       Then some testable outcome is achieved
         And something else we can check happens too

  Scenario:  A different situation
      ...
</code></pre>

For cucumber the key words use here are <strong>Feature</strong>, <strong>Scenario</strong>, <strong>Given</strong>, <strong>When</strong>, <strong>Then</strong>, and <strong>And</strong>.  Feature is used to provide identification of the test group when results are reported. Scenario is used in the same fashion.  Given, When, Then, and And are all cucumber <em><strong>methods</strong></em> that take as their argument the string that follows.  These are the steps that cucumber will report as passing, failing or pending based on the results of the corresponding step matchers in the step_definitions.rb files.  These methods are also all equivalent:
<pre><code>
      def Given(name)
        create_step('Given', name, *caller[0].split(':')[1].to_i)
      end

      def When(name)
        create_step('When', name, *caller[0].split(':')[1].to_i)
      end

      def Then(name)
        create_step('Then', name, *caller[0].split(':')[1].to_i)
      end

      def And(name)
        create_step('And', name, *caller[0].split(':')[1].to_i)
      end</code></pre>

The string argument from each of these methods is compared against all the matchers contained in the step_definitions.rb files.  A step definitions matcher looks much like this:
<pre><code>Given /there are (\d+) froobles/ do |n|
  Frooble.transaction do
    Frooble.destroy_all
    n.to_i.times do |n|
      Frooble.create! :name => "Frooble #{n}"
    end
  end
end
</code></pre>

The significant thing here is that the method (Given) takes as its argument a "regexp":http://en.wikipedia.org/wiki/Regexp bounded by  <code>/</code>.  For example, in the features given above we had the statement: <code>And some other action</code>.  This could be matched by any of the following step definition matchers if present in any step_definitions.rb file found under the features root directory.
<pre><code>Given /some other action/ do
When /some (.*) action/ do |match|
Then /(*.) other action/ do |match|
And /some other act.*/ do 
Given /(.*) other (.*)/ do |first,second|
</code></pre>

Which raises an interesting point.  If you had more than one of these matchers defined somewhere in any of your step_definitions.rb files, and not necessarily in the same file mind you, then cucumber would tell you that it found multiple matches for a single feature step and force you to distinguish them.

Note that you are not required to use a matched subpattern, <code>(.* )</code>, in the following block.  

It is considered better form by some to surround with double quotation marks, <strong><code>" "</code></strong>, elements in the feature step clauses that are meant to be taken as values. This is only a convention and one not followed by many.  However, if you choose to follow this road then you must adjust your step definition matchers accordingly.  For example:
<pre><code>Given Some determinable "business" situation</code></pre>
<pre><code>Given /determinable "(.*)" situation/ do |s|</code></pre>

Finally, you can have step definitions call other step definitions.  For example:

<pre><code>And /some "(.*)" action/  do |a|
   ...
end

When /in an invoiced non-shipped situation/ do
  Given "some \"invoiced\" action" 
  Then "some \"non-shipped\" action"
  ...
end
</code></pre>

Worthy of note is that, inside the step_definitions.rb files, one must enclose the arguments to other <strong>Given/When/Then/And</strong> methods with a string delimiter.  Because of this, if you have adopted the practice of demarcating parameter values present in the features.feature file steps with double quote marks, then you must escape these parameters when calling another definition_steps.rb matcher from inside the step_definitions.rb files.  You should also be cautious not to include the quote marks in the step_definitions parameter matchers, for <code>"(.*)"</code> is not the same as <code>(.*)</code> or <code>(".*")</code>.  If you use quotes in the .feature file steps and do not account for them in your corresponding step_definition.rb matcher methods then you will obtain variables that contain leading and trailing quotes as part of their values.

<pre><code>
Scenario: Quotes surround value elements
  Given some "required" action

# step_definitions
And /some (.*) action/ do |a|
  a => "required"

And /some "(.*)" action/ do |a|
  a => required
</code></pre>


h3. What Way do I Run the Tests?

Unless you are knowledgeable enough that you use "mocks and stubs":http://rspec.info/documentation/mocks/ then I consider it best to begin with creating a Rails migration file for the model you are testing ( or expressing features for ) followed by:<pre><code>rake db:migrate
rake db:test:prepare
</code></pre>

Testing with cucumber can be performed in several fashions.  Be aware that <code>Rake features</code>, <code>cucumber features</code>, and <code>autotest</code> with <code>ENV AUTOFEATURE=true</code> do not necessarily produce the same results given the same tests.  

Running <code>rake features</code> from the command line provides the easiest and most reliable method to run cucumber tests. The rake script provided with cucumber performs much of the background magic required to get the test database and requisite libraries properly loaded.  

Running cucumber directly from the command line requires the creation of a <code>cucumber.yml</code> file in the project root directory, even if that file remains empty.  When cucumber is run from the command line it is usually necessary to provide both the directory name containing the root directory of the tree containing feature files and the directory name containing references to the necessary library files.  In the typical project <code>cucumber features -r features</code> will normally suffice.  

Finally, running <code>autotest</code> with the environment variable <code>AUTOFEATURE=true</code> will run ALL tests, including those in <code>/test</code> and (if present) <code>/spec</code>.  As this will load all test fixtures it may leave the test database in an indefinite state when cucumber features are run.  It is wise, as always, to write cucumber steps so that they do not depend upon an empty database or themselves place the database in the requisite state.

h3. Anything Else?

For those of you that have used <code>growl</code> or <code>snarl</code> to provide desktop notifiers from autotest be advised that as of this writing cucumber did not hook into the :red :green notifier capability of autotest.  So, no popups when a step fails.  However, there exists a project to add a similar functionality to cucumber. See "Cucumber_Growler":http://github.com/paolodona/cucumber_growler/tree/master.

Recall that cucumber is an <strong><em>"integration":http://en.wikipedia.org/wiki/Integration_testing</em></strong> test harness.  It is designed to exercise the entire application stack from view down to the database.  It is certainly possible to write features and construct steps in such a fashion as to conduct unit tests.  No great harm will result.  However, this is not considered best practice by many and may prove impossible for very large projects due to the system overhead it causes and the commensurate delay in obtaining test results.

Cucumber comes preconfigured with webrat test steps.  If webrat is installed as a plugin in your project then these are available to you for view tests "out of the box".  If, instead, you have "webrat":http://github.com/brynary/webrat/wikis installed as a gem and you wish to use the gem to perform the tests then you need add this to the features/support/env.rb file:

<code>require 'webrat' if !defined?(Webrat)</code>

Calls for any additional Ruby libraries that your particular testing environment requires should typically be placed in the <code>./features/support/env.rb</code> file.

h3.  Need Help?

The best place to go for help, that I know of, is the "RSpec Forum":http://www.ruby-forum.com/forum/32 at "Ruby-Forum.com":http://www.ruby-forum.com.  There you can find access to a number of forums and gateways to mailing lists that are related to Ruby and Ruby on Rails.

2008 November 28 - J. B. Byrne