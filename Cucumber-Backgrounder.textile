h2. Or: How I Learned to Stop Worrying and Love Testing

h3. Introduction

This document deals principally with initial set up and first use of the <strong><em> Cucumber-Rails</em></strong> gem, that uses <strong><em>Cucumber</em></strong>, a behaviour driven development (BDD) tool, for designing and implementing a project using the Ruby on Rails (RoR) framework.  Discussion of "Behaviour Driven":http://en.wikipedia.org/wiki/Behavior_driven_development, "Test Driven":http://en.wikipedia.org/wiki/Test-driven_development (TDD), and "Panic Driven Development":http://en.wikipedia.org/wiki/SNAFU (SNAFU aka "Cowboy Coding":http://en.wikipedia.org/wiki/Cowboy_coding) can be found elsewhere.  Details regarding installing the Cucumber gem and its recommended support tools for RoR are found at [[Ruby on Rails]].  "Getting Started with Rails":http://www.ultrasaurus.com/code/2008/12/getting-started-with-rails.html is a useful introductory tutorial dealing with Rails and Cucumber.  

Since the original version of this article appeared, Cucumber has undergone repeated revisions and refactorings.  Among these was the sensible decision to move portions of the implementation specific to particular frameworks into their own gems.  Consequently, installing Cucumber for a framework now frequently starts with installing the specific framework Cucumber gem, which in turn pulls in the core Cucumber gem as a dependency.

h3. Where to Start?

<pre>Given you have installed the gem named "rails"
  And you have installed the gem named "cucumber-rails"
  And you have generated a RoR project named "my_project"
  And your session working directory is the Rails root directory of "my_project"
  And you have created the file cucumber.yml in the root directory
  And the file cucumber.yml contains a valid default profile

When you run "script/generate cucumber"

Then you should create a sub-directory named "features"
  And you should create the default feature and step files in the directory named "features"
  And you should create a rake task named "cucumber.rake" in "lib/tasks"
  And you should create an environment cucumber.rb in config/environments
  And you should modify config/database.yml
  .  .  .
</pre>

The foregoing is written in the style of the feature statements, called <em>steps</em>, that make up the user interface to Cucumber testing.  We will return to that topic later.  For the moment we deal with the logical arrangement of Cucumber files within the context of a RoR project.

The root level of the archetypal RoR project directory tree looks like this:

<pre><code>MyProject
|-- README
|-- Rakefile
|-- app
|-- config
|-- db
|-- doc
|-- lib
|-- log
|-- public
|-- script
|-- test
|-- tmp
`-- vendor
</code></pre>

Running script/generate cucumber adds this layout to the existing structure:
<pre><code>|-- features
|   |-- step_definitions
|   |   `-- web_steps.rb
|   `-- support
|       |-- env.rb
|       `-- paths.rb
</code></pre>

We are now ready to begin testing with Cucumber.

h3.  Where do I put Tests?

Cucumber divides testing into two parts, the outward facing feature <em>steps</em> and the inward facing <em>step definitions</em>.  As discussed elsewhere, [[Feature Introduction|features]] are descriptions of desired outcomes (<strong>Then</strong>) following upon specific events (<strong>When</strong>) under predefined conditions (<strong>Given</strong>).  They are typically used in conjunction with end-user input and, in some cases, may be entirely under end-user (in the form of a domain expert) control. Feature files are given the extension <code>.feature</code>.  

A source of potential confusion is that the term <em><strong>steps</strong></em>, when used loosely, has two, closely related but vitally distinct, meanings depending on context.  Inside feature.feature files, steps are the textual descriptions which form the body of a scenario.  These are prefaced with Given, When, Then, and And (note as well that the capitalization of these four keywords/method names is significant).  Inside a step_definitions.rb file, steps (which strictly speaking should always be called step definitions) refers to the <em>matcher</em> methods, given exactly the same names (Given, When, or Then, but *not And*),  each provided with a matcher regexp that corresponds to one or more feature steps.  Note that the method name does NOT form part of the matcher.  A Given feature clause can match a When step definition matcher.  Over time, clauses from features have come to be referred to simply as <em>features</em> while <em>steps</em> now refers almost exclusively to step-matchers

[[Step Organisation|Step definitions]], keyed by their snippets of text from the feature files, invoke blocks of ruby and rails code that usually contains assertion statements from whatever test system you have installed.  Given that Cucumber evolved out of RSpec stories it is unsurprising that the Cucumber generator once assumed that RSpec was available.  This has long since ceased to be the case.  What Cucumber does now is detect if the rspec and rspec-rails gems are installed.  If so then the rails generator builds the environment files to suit and if not then it ignores rspec and configures for test-unit instead.  The availablity of generator options is increasing over time.  To see what is available in the version of Cucumber-rails that you have installed use the command: <code>script/generate cucumber --help</code>.

As detailed above, the default features directory tree is fairly shallow.  One can put every feature into a single file in the features directory and every step in a single file in the steps_definition directory (or even in the features directory itself) if one so chooses.  One can choose to have one or more feature files for each feature together with one or more step files for each feature file; or any combination thereof.  However, Cucumber is programmed with the flexibility to support a much more expressive directory structure.  For instance:

<pre><code>|-- features
|   |-- entities
|   |   |-- entity.feature
|   |   `-- step_definitions
|   |       |-- anything.rb
|   |       `-- entity_steps.rb
|   |-- locations
|   |   |-- location.feature
|   |   `-- step_definitions
|   |       `-- location_steps.rb
|   |-- sites
|   |   `-- step_definitions
|   |-- step_definitions
|   |   `-- webrat_steps.rb
|   `-- support
|       `-- env.rb
</code></pre>

In this case the bland initial setup has been divided into sub-directories informed by model-centric testing.  This could equally well have been broken up in to model/controller/view hierarchies:

<pre><code>|-- features
|   |-- models
|   |   |-- entities
|   |   |   |-- entity.feature
|   |   |   `-- step_definitions
|   |   |       |-- anything.rb
|   |   |       `-- entity_steps.rb
|   |-- views
|   |   |   |-- entity_new
|   |   |   `-- step_definitions
|   |   |       `-- entity_new_steps.rb
|   |-- step_definitions
|   |   `-- webrat_steps.rb
|   `-- support
|       `-- env.rb
</code></pre>

Consider, however, that the Cucumber feature scaffold generator will generate the files it produces in conformance with the default layout, with the <code>manage_frooble.feature</code> file placed in <code>./features</code> and the <code>frooble_steps.rb</code> file in <code>./features/step_definitions</code>. Also be aware that, regardless of the directory structure employed, Cucumber effectively flattens the features directory tree when running tests.  By this I mean that anything ending in .rb under the start point for a Cucumber feature run is searched for feature matches.  So that a step contained in <code>features/models/entities/step_definitions/anything.rb</code> can be used in a feature file contained in <code>features/views/entity_new</code>.  It is also worth noting that step files can be called anything so long as they end in <code>.rb</code>.  

h3. How do I Write Tests?

Constructing ones first tests, or features as BDD purists prefer, is often accompanied by what can only be described as <em>"writer's block":http://en.wikipedia.org/wiki/Writer%27s_block</em>.  While detailed discussion of feature writing and step construction are provided elsewhere (see [[Given-When-Then]] and "Telling a Good Story":http://blog.josephwilk.net/ruby/telling-a-good-story-rspec-stories-from-the-trenches.html), perhaps the easiest thing to do for the first time tester/behaviourist is to use Cucumber's built-in generator to create a feature scaffold and then modify it.  
<pre><code>script/generate feature Frooble name color description
      exists  features/step_definitions
      create  features/manage_froobles.feature
      create  features/step_definitions/frooble_steps.rb
</code></pre>

While scaffolding provides a comforting illusion of progress through its voluminous production of template code, in practice it proves important to write each test/feature step <em><strong>one at a time</strong></em>.  After each new feature step is added then you should immediately create the corresponding step definition method.  Following the creation of the actual test/step definition that your new application should satisfy you must first prove to yourself that it fails.  Then, and only then, should you write the minimal application code that gets the new test/step definition to pass.  Once this cycle is complete then move on to the next feature step.

It is often tempting to just <em>skip ahead</em> and complete as many scenarios and feature steps as one can imagine.  In some cases limited access to domain experts and end users may require that many feature steps be completed long before coding the associated step definitions is undertaken. Nonetheless, in the long run, it has proven best practice to write feature steps and step definitions incrementally, using the absolute minimum of code; and then immediately implement the new feature step requirement in application code, also using the minimum code to satisfy it.  This is a hard discipline to accept but the value is that with this approach you will rarely have untested code anywhere in your application and your application will only have code that satisfies required features.

If you do anticipate feature steps then omitting any matcher for them in the step definitions files causes these steps to be reported as missing by Cucumber, which helpfully provides a suggested method and agument to implement.  Stub matchers have an explicit <strong><em>pending</em></strong> method avaiable to designate pending step definitions.

A single <strong><em>Feature</em></strong> is typically contained in its own file (ending in <code>.feature</code>).  Each Feature usually consists of multiple <strong><em>Scenarios</strong></em>.  Each Scenario consists of three sections, <strong>Given</strong>, <strong>When</strong> and <strong>Then</strong>.  Each section consists of one or more clauses (steps) that are used to match test step definitions. The conventional arrangement is:

<pre>Feature: Some terse yet descriptive text of what is desired
In order that some business value is realized
An actor with some explicit system role
Should obtain some beneficial outcome which furthers the goal
To Increase Revenue | Reduce Costs | Protect Revenue  (pick one)

  Scenario:   Some determinable business situation
      Given some condition to meet
         And some other condition to meet
       When some action by the actor
         And some other action
         And yet another action
       Then some testable outcome is achieved
         And something else we can check happens too

  Scenario:  A different situation
      ...
</code></pre>

For Cucumber features the key words used here are <strong>Feature</strong>, <strong>Scenario</strong>, <strong>Given</strong>, <strong>When</strong>, <strong>Then</strong>, and <strong>And</strong>.  Feature is used to provide identification of the test group when results are reported. Scenario is used in the same fashion.  Given, When, Then, and And are all Cucumber <em><strong>methods</strong></em> that take as their argument the string that follows.  These are the steps that Cucumber will report as passing, failing or pending based on the results of the corresponding step matchers in the step_definitions.rb files.  These four methods are also all equivalent.
<pre><code>
def Given(name)
  create_step('Given', name, *caller[0].split(':')[1].to_i)
end
def When(name)
  create_step('When', name, *caller[0].split(':')[1].to_i)
end
def Then(name)
  create_step('Then', name, *caller[0].split(':')[1].to_i)
end
def And(name)
  create_step('And', name, *caller[0].split(':')[1].to_i)
end
</code></pre>

The string argument from each of these methods is compared against all the matchers contained in the step_definitions.rb files.  A step definitions matcher looks much like this:
<pre><code>Given /there are (\d+) froobles/ do |n|
  Frooble.transaction do
    Frooble.destroy_all
    n.to_i.times do |n|
      Frooble.create! :name => "Frooble #{n}"
    end
  end
end
</code></pre>

The significant thing here is that the method (Given) takes as its argument a "regexp":http://en.wikipedia.org/wiki/Regexp bounded by  <code>/</code>.  For example, in the features provided above we had the statement: <code>And some other action</code>.  This could be matched by any of the following step definition matchers if present in any step_definitions.rb file found under the features root directory.
<pre><code>Given /some other action/ do
When /some (.*) action/ do |match|
Then /(*.) other action/ do |match|
Given /(.*) other (.*)/ do |first,second|
</code></pre>
But, this will throw a method missing exception:
<pre>
And /some other act.*/ do 
</pre>

The exception occurs because *_And_* is not defined as a steps definition method, but only as a feature step method.  The step definition match depends only upon the pattern following the Given/When/Then method and not upon the step method itself.  I have therefore adopted the practice of only using <code>When /I have a match/ do</code> in my step definitions files as *When* has a more natural appearance for a matcher.

If more than one matcher in all of the step definitions files matches a feature step then Cucumber complains that it found multiple step definition matches for that step and forces you to distinguish them.  You can force Cucumber to make a decision instead by passing the switch <code>--guess</code> on the command line.

It is considered better form by some to surround with double quotation marks, <strong><code>" "</code></strong>, elements in the feature step clauses that are meant to be taken as values. This is only a convention and one not followed by many.  However, if you choose to follow this road then you must adjust your step definition matchers accordingly.  For example:
<pre><code>Given Some determinable "business" situation</code></pre>
<pre><code>Given /determinable "(.*)" situation/ do |s|</code></pre>

Finally, you can have step definitions call other step definitions, including those contained in other step definitions files.  For example:

<pre><code>When /some "(.*)" action/  do |a|
   ...
end

When /in an invoiced non-shipped situation/ do
  Given "some \"invoiced\" action" 
  Then "some \"non-shipped\" action"
  ...
end
</code></pre>

If one step definition calls another step definition then the matcher argument to the called <strong>Given/When/Then</strong> method must be enclosed with string delimiters.  Because of this, if you have adopted the practice of demarcating parameter values present in feature steps with double quotation marks then, you must escape these quotation marks when calling another definition_steps.rb matcher from inside a step_definitions.rb file.  You must take care not to include the quote marks in the step_definitions parameter matchers, for <code>"(.*)"</code> is not the same as <code>(.*)</code> or <code>(".*")</code>.  If you use quote delimited values in the .feature file steps and do not account for them in the corresponding step_definition.rb matcher regexp then you will obtain variables that contain leading and trailing quotes as part of their value.

<pre><code>
Scenario: Quotes surround value elements
  Given some "required" action

# step_definitions
When /some (.*) action/ do |a|
  a => "required"

When /some "(.*)" action/ do |a|
  a => required
</code></pre>

In a manner similar to my convention of using only using the *When* method for step definition matchers, since When, Given, and Then are all equivalent inside the step definitions file I have adopted the convention of calling other step definitions within matchers using the Then method, thus:

<pre>
When /my matcher named (.*)/ do |match|
  Then "my other matcher named \"#{match}\""
end
</pre>

The choice of method has no impact on the result but, <em>When</em> and <em>Then</em> used in this fashion seem to me to read more naturally.

If all your feature's scenarios share the same 'setup' feature steps then Cucumber provides the <em>Background</em> section.  Steps contained within a Background section are run before each of the scenarios.

<pre>
Feature: .  .  .
  Background: .  .  .
  Scenario: .  .  .
</pre>  

h3. What Way do I Run the Tests?

Unless you are knowledgeable enough that you use "mocks and stubs":http://rspec.info/documentation/mocks/ then I consider it best to begin with creating a Rails migration file for the model you are testing ( or expressing features for ) followed by:<pre><code>rake db:migrate
rake db:test:prepare
</code></pre>

However, there is an important environmental consideration to keep in mind when using an actual database for testing: Cucumber, by default, uses database transactions and these transactions are rolled back after each scenario.  This makes out-of-process testing problematic and may result in some unanticipated outcomes under certain scenarios.  Transactions can be turned off, but then your features become responsible for ensuring that the database is in a condition suitable for testing.  Cucumber provides hooks to accomplish this and the gem "Database-Cleaner":http://github.com/bmabey/database_cleaner is configured in support/env.rb to assist. 

Testing with Cucumber can be performed in several fashions.  Be aware that <code>rake cucumber</code>, <code>cucumber features</code>, and <code>autotest</code> with <code>ENV AUTOFEATURE=true</code> do not necessarily produce the same results given the same tests.  

Running <code>rake cucumber</code> from the command line provides the simplest, if not the speediest, method to run Cucumber tests. The rake script provided with cucumber performs much of the background magic required to get the test database and requisite libraries properly loaded.  The Cucumber Rake task now recognises the @wip tag, so <code>rake cucumber:wip</code> will run only those scenarios tagged with <strong>@wip</strong>.  For example, given a feature file containing:
<pre>
Feature: .  .  .

  Scenario: A

  @wip
  Scenario: B

  Scenario: C
</pre>

running the command <code>rake cucumber:wip</code> will run only the steps contained inside Scenario B.

Running Cucumber directly from the command line requires the creation of a <code>cucumber.yml</code> file in the project root directory and it must contain a default profile (for example: <code>default: --require features --format pretty</code>.  When Cucumber is run from the command line it is usually necessary to provide both the directory name containing the root directory of the tree containing feature files and the directory name containing references to the necessary library files.  In the typical project <code>cucumber features -r features</code> will normally suffice.  

Finally, running <code>autotest</code> with the environment variable <code>AUTOFEATURE=true</code> will run ALL tests, including those in <code>/test</code> and (if present) <code>/spec</code>.  As this will load all test fixtures the test database may be left in an indefinite state when Cucumber features are run.  It is wise, as always, to write Cucumber steps either so that they do not depend upon an empty database or they place the database in the requisite state.

h3. Anything Else?

The terminology for elements of Behaviour Driven Development differs somewhat from that employed by Test Driven Development.  This article, because of the introductory nature of its contents, tends to blur the semantic distinction between these two divergent philosophies.

Realize that tests/assertions/expectations either pass or fail (raise an error) and that fail is NOT the same as false, whereas anything but fail is a pass.  When, in RSpec, <code>something.should_be 0</code> and it is not, then what is returned is an error exception and not a boolean value.  In raw Cucumber (pardon the pun) one writes <code>fail if false</code> and not simply <code>false</code>.  A little reflection reveals why this is so, since false might be the expected successful outcome of a test and thus not an error.  However, the distinction between fail and false escaped my notice until I was confronted with it in an actual test suite.

If you are testing with intent then you should be using the "ruby-debug gem":http://rubyforge.org/projects/ruby-debug/.  A really neat method to drop into an interactive debugging session _inside a Cucumber step definition_ using ruby-debug was provided by "Scott Taylor on the rspec mailing list":http://www.ruby-forum.com/topic/175732#769713.  Just put these statements inside the step definition at the point that you wish to debug:  <code>require 'rubygems'; require 'ruby-debug'; debugger</code>.  When that code interrupts then type <code>irb</code> and you open an interactive debugging session wherein you can step forwards and backwards inside the code under test to determine exactly where the breakage is happening.  Alternatively, you can add <code>require 'rubygems'; require 'ruby-debug';</code> to your support/env.rb file (see below) and just put @debugger@ wherever you desire it inside any step definition.

Recall that Cucumber is an <strong><em>"integration":http://en.wikipedia.org/wiki/Integration_testing</em></strong> test harness.  It is designed to exercise the entire application stack from view down to the database.  It is certainly possible to write features and construct step definitions in such a fashion as to conduct unit tests and no great harm will result.  However, this is not considered best practice by many and may prove insupportable for very large projects due to the system overhead it causes and the commensurate delay in obtaining test results.

Cucumber-Rails preconfigured with support for integration testing using either "Capybara":http://github.com/jnicklas/capybara (script/generate  cucumber --capybara) or "Webrat":http://github.com/brynary/webrat (script/generate cucumber), the default.  If you do not know what Capybara or Webrat are or do,  and you are doing web application testing, then you should find out more about "Capybara":http://github.com/jnicklas/capybara and "Webrat":http://github.com/brynary/webrat, both.

The Cucumber generator will set up the necessary support files whichever you choose.

Calls for any additional Ruby libraries that your particular testing environment may require are typically be placed in the <code>./features/support/local_env.rb</code> file.  I advise against putting local customization in <code>support/env.rb</code> as it is typically overwritten by <code>script/generate cucumber</code>.  As a matter of good practice you should always run <code>script/generate cucumber</code> whenever you install an updated version.  You should do the same for rspec as well.

Those of you that have used <code>growl</code> or <code>snarl</code> to provide desktop notifiers from autotest are advised that, as of this writing, Cucumber did not hook into the :red :green notifier capability of autotest;  so, no popups when a step fails.  However, there exists a project to add a similar functionality to Cucumber. See "Cucumber_Growler":http://github.com/paolodona/cucumber_growler/tree/master.

<code>autotest</code> is installed via the "ZenTest":http://www.zenspider.com/ZSS/Products/ZenTest/ gem.  If you use autotest then take a look at the contents of <code>example_dot_autotest.rb</code> in the ZenTest gem root directory.

h3.  Need Help?

The best place to go for help, that I know of, is the "Google Cucumber Group":http://groups.google.com/group/cukes.

If you find a bug in Cucumber, or wish a new feature added, then you should open a ticket at "Lighthouse":http://rspec.lighthouseapp.com/projects/16211-cucumber/ for it.

2008 November 28 - J. B. Byrne initial
2010 January 17 - J.B. Byrne revised