Step argument transforms help your step definitions be more by DRY by allowing you to refactor common operations performed on the step definition arguments to a common operation.  Before each step definition's captured Regexp groups are yielded as arguments to the step definition block, an attempt is made to match them against registered @Transform@ objects.  If a capture value matches one of the @Transform@ objects the result of @Transform@'s block yielded to step definition as the argument.


h2. Registering a Transform


```ruby
Transform /^(-?\d+)^/ do |number|
  number.to_i
end
```

* Uses the keyword @Transform@
* Has a regular expression that is compared against all the captures of the step definition
* Implements a block whose result is sent to the step definition block as the matching argument 


h2. Transforms in Execution

The above transform converts any step definition captures and converts them automatically to integers.

```ruby
# features/step_definitions/user_steps.rb

Transform /^(-?\d+)^/ do |number|
  number.to_i
end

Then /^a user, named '([^']+)', should have (\d+) followers$/ do |name,count|
  # Without the transform your count object would be a string and not a number 
  count.should be_kind_of(Numeric)
  #...  
end
```

h2. Transforming Tables

Step argument transforms can also be used with tables. A table is matched via a comma-delimited list of the column headers and the 'table:' prefix:


```gherkin
# features/table.feature
Scenario: setting up via table
  Given ...
  When ...
  Then I should have
    | name  | age |
    | corey | 36  |
```


```ruby
# features/step_definitions/user_steps.rb
Transform /^table:name,age$/ do |table|
  table.hashes.map { |hash| hash[:name] }.map {|name| User.find_by_name(name)}
end
```

You can also use @Table#.map_column!@ and @Table#.map_headers!@ to modify tables. See [[RDoc]] for details.


h2. Transform Wisdom

Transforms are powerful and it is important to take care how you implement them as mistakes with them can often introduce strange and unexpected behavior.


*1. Transforms always require that you specify a block variable even if you do not specify any groups to capture.*  

With no capture groups specified the entire value is returned as a string to the block.  This is contrast to how step definitions perform and can often trip you up.  Cucumber will fail execution with a warning when you fail to specify at least one variable.

```ruby
# Valid - without the capture group () specified
Transform /^-?\d+^/ do |number|
  number.to_i
end

# Invalid - Cucumber will raise an error when you execute the test suite
Transform /^-?\d+^/ do
  number.to_i
end
```

When you specify capture groups, each capture will be yielded to the block as you have likely come to expect from step definitions would expect.

```ruby
# Converts the numeric abbreviation for KB/MB to the size 
Transform /^(\d+)\s?(KB|MB)$/ do |quantity,unit|
  quantity.to_i * (unit =~ /MB/ ? 1000000 : 1000)
end
```


*2. Ensure that you specify the caret (^) and dollar sign ($) at the start and end of the regular expression.*

The following transform, adds onto the integer conversion before it, treats an 'a' or 'an' as the integer value of 1.  This may be useful in step definitions where you might want to say something like _"a user"_ instead of _"1 user"_.

```ruby
# Convert 'a' or 'an' to the integer value 1
Transform /^(an?|-?\d+)$/ do |amount|
  amount =~ /an?/ ? 1 : amount.to_i
end
```

However, removing the caret and dollar sign will allow this step definition to match *ANY* step definition captures that have the value _a_ in it.  This will likely wreak havoc as the value 1 starts appearing in a large set of your step definitions.


*3. In step definitions capture contextual to ensure that the correct transform is used.*

```ruby
Transform /^a user,? named '([^']+)',?$/ do |name|
  User.find_by_name(name)
end

# i.e. Then a user, named 'aslakhellesoy', should have 317 followers
Then /^(a user, named '(?:[^']+)',) should have (\d+) followers$/ do |name,count|
  user.should_not be_nil
  user.should be_kind_of(User)
  user.friends.should == count.to_i
end
```

Before using a transform, you would have likely only wanted to match the name, the value in single quotes, as a group  However, matching only the name would likely open our transform up to a large number of arguments and we wouldn't be assured that we were getting a user.


*4. Register a @Transform@ in the same file in which they are being employed.*

If you find that you transform is used by multiple step definitions, move the transform to a file in the support directory (i.e. @step_definitions/support/numeric_transforms.rb@).


h2. Further Examples

"Larry Diehl at Engine Yard":http://www.engineyard.com/blog/2009/cucumber-step-argument-transforms/
