Step argument transforms help your step definitions be more DRY. You can use the <code>Transform</code> method to register a regular expression along with a code block. Before captured Regexp groups get yielded as arguments to step definitions, an attempt is made to match them against any registered <code>Transform</code>. If there is a match, the return value of the block supplied with the transform is yielded as the step definition argument instead. Here is an example:

<pre>
# support file
Transform /^user \w+$/ do |step_arg|
  User.find_by_username /(\w+)$/.match(step_arg)[0]
end

# step definition file
Then /^(user \w+) should be friends with (user \w+)$/ do |user, friend|
  user.should be_friends_with(friend)
end

# feature file
Scenario: friend'ing
  Given ...
  When ...
  Then user larrytheliquid should be friends with user dastels
</pre> 

Note that sometimes you may not need to parse the entire step_arg and may only care about a specific Regexp capture group being matched. For this more common case, you can use an optional syntax for <code>Transform</code> where the block supplied has arguments that correspond to capture groups in the registered Regexp:

<pre>
# support file
Transform /^user (\w+)$/ do |username|
  User.find_by_username username
end
</pre>

One key thing to remember is to provide some contextual data like "user" so you don't end up transforming every single argument to a step definition. See "this blog post":http://www.engineyard.com/blog/2009/cucumber-step-argument-transforms/ for a more detailed explanation and examples.

Step argument transforms can also be used with tables. A table is matched via a comma-delimited list of the column headers and the 'table:' prefix:

<pre>
# feature file
Scenario: setting up via table
  Given ...
  When ...
  Then I should have
    | name  | age |
    | corey | 36  |

#support file
Transform /^table:name,age$/ do |table|
  table.hashes.map { |hash| hash[:name] }.map {|name| Person.find_by_name name}
end
</pre>
